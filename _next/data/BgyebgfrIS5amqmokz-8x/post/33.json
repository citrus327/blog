{"pageProps":{"html":"<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/17166940/165703985-8abaaa1e-76ed-4981-a980-d5825d911e60.png\"><img width=\"862\" alt=\"image\" src=\"https://user-images.githubusercontent.com/17166940/165703985-8abaaa1e-76ed-4981-a980-d5825d911e60.png\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\"><a href=\"https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn854d/\" rel=\"nofollow\">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn854d/</a></p>\n<p dir=\"auto\">思路：</p>\n<ul dir=\"auto\">\n<li>当n等于1的时候，只需要跳一次即可，只有一种跳法，记f(1)=1</li>\n<li>当n等于2的时候，可以先跳一级再跳一级，或者直接跳二级，共有2种跳法，记f(2)=2</li>\n<li>当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来，所以总共有f(3)=f(2)+f(1)；</li>\n<li>同理当等于n的时候，总共有f(n)=f(n-1)+f(n-2)(这里n&gt;2)种跳法。</li>\n</ul>\n<p dir=\"auto\">递归</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    return climbStairs(n-2) + climbStairs(n-1);\n};\"><pre><span class=\"pl-c\">/**</span>\n<span class=\"pl-c\"> * <span class=\"pl-k\">@param</span> {<span class=\"pl-smi\">number</span>} n</span>\n<span class=\"pl-c\"> * <span class=\"pl-k\">@return</span> {<span class=\"pl-smi\">number</span>}</span>\n<span class=\"pl-c\"> */</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-en\">climbStairs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">function</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span> <span class=\"pl-c1\">==</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">return</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span> <span class=\"pl-c1\">==</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">return</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-en\">climbStairs</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-c1\">-</span><span class=\"pl-c1\">2</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">+</span> <span class=\"pl-en\">climbStairs</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-c1\">-</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">非递归</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    var cache = {}\n    cache[1] = 1\n    cache[2] = 2\n\n    for (let i = 3; i &lt; n + 1; i++) {\n        cache[i] = cache[i -1 ] + cache[i - 2]\n    }\n    return cache[n]\n};\"><pre><span class=\"pl-c\">/**</span>\n<span class=\"pl-c\"> * <span class=\"pl-k\">@param</span> {<span class=\"pl-smi\">number</span>} n</span>\n<span class=\"pl-c\"> * <span class=\"pl-k\">@return</span> {<span class=\"pl-smi\">number</span>}</span>\n<span class=\"pl-c\"> */</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-en\">climbStairs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">function</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">var</span> <span class=\"pl-s1\">cache</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n    <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span>\n    <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">2</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span>\n\n    <span class=\"pl-k\">for</span> <span class=\"pl-kos\">(</span><span class=\"pl-k\">let</span> <span class=\"pl-s1\">i</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span> <span class=\"pl-s1\">i</span> <span class=\"pl-c1\">&lt;</span> <span class=\"pl-s1\">n</span> <span class=\"pl-c1\">+</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span> <span class=\"pl-s1\">i</span><span class=\"pl-c1\">++</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">i</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">i</span> <span class=\"pl-c1\">-</span><span class=\"pl-c1\">1</span> <span class=\"pl-kos\">]</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">i</span> <span class=\"pl-c1\">-</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">]</span>\n    <span class=\"pl-kos\">}</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">cache</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">n</span><span class=\"pl-kos\">]</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<blockquote>\n<p dir=\"auto\">所有递归都会重新执行之前的函数，性能上有问题，通过建立cache，缓存计算结果，节省空间<br>\n所有递归都能使用这种解法优化</p>\n</blockquote>"},"__N_SSG":true}