{"pageProps":{"html":"<h1 dir=\"auto\">理解Node.js的模块加载</h1>\n<blockquote>\n<p dir=\"auto\">本文为阅读<a href=\"https://www.infoq.cn/article/nodejs-module-mechanism/\" rel=\"nofollow\">深入浅出 Node.js（三）：深入 Node.js 的模块机制</a>&gt;之后的总结。作为日常的知识储备，方便日后查看和消化。</p>\n</blockquote>\n<h2 dir=\"auto\">起因</h2>\n<p dir=\"auto\">JavaScript本来并没有模块化这一说，作为一种脚本语言却缺少模块化实现就很难在此之上有所拓展。<a href=\"http://www.commonjs.org\" rel=\"nofollow\">CommonJs</a>规范的出现改变了这一点，其最终目标是拓展JavaScript的生态范围。Node.js实现了CommonJs的模块引入规范，NPM实现了包规范。两者契合就有了现在的Node.js模块化。</p>\n<h2 dir=\"auto\">模块载入策略</h2>\n<p dir=\"auto\">原生模块和文件模块都有模块缓存一说，在载入某模块之后，会缓存起来待之后使用。</p>\n<h3 dir=\"auto\">文件模块</h3>\n<p dir=\"auto\">这种很常见，因为最基本的命令 <code class=\"notranslate\">node app.js</code> 就是直接将 app.js 作为文件模块引入执行。加载文件模块是由原生模块<code class=\"notranslate\">Module</code>去完成的，该原生模块在启动时已经被加载。</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// bootstrap main module.\nModule.runMain = function () {\n    // Load the main module--the command line argument.\n    Module._load(process.argv[1], null, true);\n};\"><pre><span class=\"pl-c\">// bootstrap main module.</span>\n<span class=\"pl-v\">Module</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">runMain</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Load the main module--the command line argument.</span>\n    <span class=\"pl-v\">Module</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">_load</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">process</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">argv</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">null</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\"><code class=\"notranslate\">Module._load</code>静态方法在分析文件名之后，会创建对应Module</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"var module = new Module(id, parent);\"><pre><span class=\"pl-k\">var</span> <span class=\"pl-s1\">module</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Module</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">parent</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">这里举的例子是用 <code class=\"notranslate\">app.js</code> 为例的，Node.js支持3类文件的解析，分别是 <code class=\"notranslate\">.js</code> <code class=\"notranslate\">.json</code> <code class=\"notranslate\">.node</code></p>\n<p dir=\"auto\">Node.js会用一个闭包函数去包装引用文件的内容</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function (exports, require, module, __filename, __dirname) {\n    // Your file content\n});\"><pre><span class=\"pl-kos\">(</span><span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">exports</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">require</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">module</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">__filename</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">__dirname</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Your file content</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">这也是为什么Node.js的模块内，会有类似全局变量的<code class=\"notranslate\">require</code> <code class=\"notranslate\">module</code> <code class=\"notranslate\">export</code> <code class=\"notranslate\">__dirname</code>的存在</p>\n<h3 dir=\"auto\">模块查找优先级</h3>\n<p dir=\"auto\">在说载入Node.js原生模块之前，先说明一下require的模块查找优先级</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067\"><img src=\"https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067\" alt=\"require的模块查找策略\" data-canonical-src=\"https://static001.infoq.cn/resource/image/85/65/851bca4acc603ce08d1011243191f665.jpg\" style=\"max-width: 100%;\"></a></p>\n<h3 dir=\"auto\">原生模块</h3>\n<p dir=\"auto\">Node.js含有很多原生模块，例如http, fs, path等。<br>\n看这个图中会发现，如果目标模块在文件缓存区，原生模块的载入优先级会在文件缓存区之后。</p>\n<p dir=\"auto\">也就是说如果你有一个http.js，如果这个文件先被引入（即载入文件缓存区），在之后执行<code class=\"notranslate\">require('http')</code>会直接引入文件而非Node.js原生模块。</p>\n<p dir=\"auto\">其实这个场景不会存在，在Node.js环境下，引入文件肯定会是用文件的path，哪怕运行入口和http.js在同级，也就是说</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const http = require('http')\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">http</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">require</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'http'</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">这个肯定会载入原生模块，文件的引入是用</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const httpFile = require('./http')\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">httpFile</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">require</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'./http'</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">所以不用担心会有同名的文件模块和原生模块。</p>\n<h2 dir=\"auto\">模块查找策略</h2>\n<p dir=\"auto\">如果使用require去引入一个模块，其查找优先级是</p>\n<ol dir=\"auto\">\n<li>从当前文件目录开始查找 node_modules 目录</li>\n<li>然后依次进入父目录，查找父目录下的 node_modules 目录</li>\n<li>依次迭代，直到根目录下的 node_modules 目录</li>\n</ol>\n<p dir=\"auto\">如下代码可以在Node.js的环境下使用，这个module.path就是查找的顺序</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"console.log(module.paths);\n// 输出\n[ \n  '/Users/hao/Work/github/node_module_test/node_modules',\n  '/Users/hao/Work/github/node_modules',\n  '/Users/hao/Work/node_modules',\n  '/Users/hao/node_modules',\n  '/Users/node_modules',\n  '/node_modules' \n]\n\"><pre><span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">module</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">paths</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// 输出</span>\n<span class=\"pl-kos\">[</span> \n  <span class=\"pl-s\">'/Users/hao/Work/github/node_module_test/node_modules'</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">'/Users/hao/Work/github/node_modules'</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">'/Users/hao/Work/node_modules'</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">'/Users/hao/node_modules'</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">'/Users/node_modules'</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">'/node_modules'</span> \n<span class=\"pl-kos\">]</span></pre></div>\n<p dir=\"auto\">结合之前的图示，完整的策略为：</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067\"><img src=\"https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067\" alt=\"模块查找策略\" data-canonical-src=\"https://static001.infoq.cn/resource/image/14/cb/1416ddabad3dcd4ffca600f88a7613cb.jpg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">简而言之，如果 require 绝对路径的文件，查找时不会去遍历每一个 node_modules 目录，其速度最快。其余流程如下：</p>\n<ol dir=\"auto\">\n<li>从 module path 数组中取出第一个目录作为查找基准。</li>\n<li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。</li>\n<li>尝试添加.js、.json、.node 后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li>\n<li>尝试将 require 的参数作为一个包来进行查找，读取目录下的 package.json 文件，取得 main 参数指定的文件。</li>\n<li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第 3 条查找。</li>\n<li>如果继续失败，则取出 module path 数组中的下一个目录作为基准查找，循环第 1 至 5 个步骤。</li>\n<li>如果继续失败，循环第 1 至 6 个步骤，直到 module path 中的最后一个值。</li>\n<li>如果仍然失败，则抛出异常。</li>\n</ol>\n<p dir=\"auto\">整个查找过程十分类似原型链的查找和作用域的查找。所幸 Node.js 对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。</p>\n<h2 dir=\"auto\">CommonJs 包规范</h2>\n<p dir=\"auto\">一个符合 CommonJS 规范的包应该是如下这种结构：</p>\n<ol dir=\"auto\">\n<li>一个 package.json 文件应该存在于包顶级目录下</li>\n<li>二进制文件应该包含在 bin 目录下。</li>\n<li>JavaScript 代码应该包含在 lib 目录下。</li>\n<li>文档应该在 doc 目录下。</li>\n<li>单元测试应该在 test 目录下。</li>\n</ol>\n<p dir=\"auto\">根据上文说的查找逻辑，其实很重要的一点就是package.json里的main字段。<br>\n这个定义了包的入口文件所在。</p>\n<h2 dir=\"auto\">为何有些模块可以在Node.js运行也可以在浏览器端运行</h2>\n<p dir=\"auto\">浏览器端的Js代码都是通过script标签引入并执行。</p>\n<p dir=\"auto\">Node.js是会通过上文中提到的闭包函数去进行包装</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function (exports, require, module, __filename, __dirname) {\n    // Your file content\n});\"><pre><span class=\"pl-kos\">(</span><span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">exports</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">require</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">module</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">__filename</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">__dirname</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Your file content</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">Node.js由于是个闭包，所以不会污染全局变量。浏览器端则不然。<br>\n有些包可以在Node.js和浏览器端运行，也是利用闭包和变量检测去完成模块的解析和运行的。<br>\n例如著名类库underscore的定义方式</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function () {\n    // Establish the root object, `window` in the browser, or `global` on the server.\n    var root = this;\n    var _ = function (obj) {\n            return new wrapper(obj);\n        };\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' &amp;&amp; module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else if (typeof define === 'function' &amp;&amp; define.amd) {\n        // Register as a named module with AMD.\n        define('underscore', function () {\n            return _;\n        });\n    } else {\n        root['_'] = _;\n    }\n}).call(this);\"><pre><span class=\"pl-kos\">(</span><span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Establish the root object, `window` in the browser, or `global` on the server.</span>\n    <span class=\"pl-k\">var</span> <span class=\"pl-s1\">root</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">var</span> <span class=\"pl-en\">_</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">obj</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-s1\">wrapper</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">obj</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">exports</span> <span class=\"pl-c1\">!==</span> <span class=\"pl-s\">'undefined'</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">module</span> <span class=\"pl-c1\">!==</span> <span class=\"pl-s\">'undefined'</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-smi\">module</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">exports</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-s1\">exports</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">module</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">exports</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">_</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-kos\">}</span>\n        <span class=\"pl-s1\">exports</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">_</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">_</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">define</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">'function'</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-s1\">define</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">amd</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-c\">// Register as a named module with AMD.</span>\n        <span class=\"pl-en\">define</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'underscore'</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-k\">return</span> <span class=\"pl-en\">_</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span> <span class=\"pl-k\">else</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-s1\">root</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'_'</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">_</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">call</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">以上代码优先检测了exports是否存在，也就是CommonJs规范，如果存在exports对象，直接将目标对象定义在exports上。</p>\n<p dir=\"auto\">然后检测了define是否存在，这是amd的模块规范，以适配amd的模块规范。</p>\n<p dir=\"auto\">最终如果检测不到CommonJs和AMD的运行环境，则认为是在一个沙盒内运行。</p>\n<p dir=\"auto\">可以看到第一行的<code class=\"notranslate\">var root = this</code>，这个this在浏览器端即为window。也就是说如果运行环境既不是CommmonJs也不是AMD，则直接挂在window对象下。</p>\n<p dir=\"auto\">现在很多的打包工具都会根据打包的target（UMD, CommonJs等）进行build, 会自动的拼接这些判断，所以其实日常开发js插件/模块，是不需要担心这些环境检测的代码的。</p>"},"__N_SSG":true}