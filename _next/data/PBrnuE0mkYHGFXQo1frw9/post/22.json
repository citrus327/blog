{"pageProps":{"html":"<h2 dir=\"auto\">enum</h2>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"enum IpAddrKind {\n  V4,\n  V6,\n}\n\nstruct IpAddr {\n  kind: IpAddrKind,\n  address: String,\n}\n\nlet home = IpAddr {\n  kind: IpAddrKind::V4,\n  address: String::from(&quot;127.0.0.1&quot;),\n};\n\nlet loopback = IpAddr {\n  kind: IpAddrKind::V6,\n  address: String::from(&quot;::1&quot;),\n};\"><pre><span class=\"pl-k\">enum</span> <span class=\"pl-en\">IpAddrKind</span> {\n  V4,\n  V6,\n}\n\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">IpAddr</span> {\n  kind: IpAddrKind,\n  address: <span class=\"pl-k\">String</span>,\n}\n\n<span class=\"pl-k\">let</span> home <span class=\"pl-k\">=</span> IpAddr {\n  kind: IpAddrKind<span class=\"pl-k\">::</span>V4,\n  address: <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"127.0.0.1\"</span>),\n};\n\n<span class=\"pl-k\">let</span> loopback <span class=\"pl-k\">=</span> IpAddr {\n  kind: IpAddrKind<span class=\"pl-k\">::</span>V6,\n  address: <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"::1\"</span>),\n};</pre></div>\n<p dir=\"auto\">声明enum并在struct中使用。</p>\n<p dir=\"auto\">想要表达如上的类型，其实可以直接使用enum</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"enum IpAddr {\n  V4(String),\n  V6(String),\n}\n\nlet home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));\n\nlet loopback = IpAddr::V6(String::from(&quot;::1&quot;));\"><pre><span class=\"pl-k\">enum</span> <span class=\"pl-en\">IpAddr</span> {\n  <span class=\"pl-en\">V4</span>(<span class=\"pl-k\">String</span>),\n  <span class=\"pl-en\">V6</span>(<span class=\"pl-k\">String</span>),\n}\n\n<span class=\"pl-k\">let</span> home <span class=\"pl-k\">=</span> IpAddr<span class=\"pl-k\">::</span><span class=\"pl-en\">V4</span>(<span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"127.0.0.1\"</span>));\n\n<span class=\"pl-k\">let</span> loopback <span class=\"pl-k\">=</span> IpAddr<span class=\"pl-k\">::</span><span class=\"pl-en\">V6</span>(<span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"::1\"</span>));</pre></div>\n<p dir=\"auto\">enum跟struct很类似，根据以上的例子可以看出</p>\n<ol dir=\"auto\">\n<li>使用enum在第一个例子里会比struct更方便</li>\n<li>each variant can have different types and amounts of associated data</li>\n</ol>\n<p dir=\"auto\">enum可以被实现，定义成员方法</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"#[derive(Debug)]\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nimpl IpAddr {\n    fn say (&amp;self) {\n        println!(&quot;{:#?}&quot;, &amp;self);\n    }\n}\n\nfn main() {\n    let home = IpAddr::V4(127, 0, 0, 1);\n    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));\n    home.say();\n    loopback.say();\n}\"><pre>#[derive(Debug)]\n<span class=\"pl-k\">enum</span> <span class=\"pl-en\">IpAddr</span> {\n    <span class=\"pl-en\">V4</span>(<span class=\"pl-k\">u8</span>, <span class=\"pl-k\">u8</span>, <span class=\"pl-k\">u8</span>, <span class=\"pl-k\">u8</span>),\n    <span class=\"pl-en\">V6</span>(<span class=\"pl-k\">String</span>),\n}\n\n<span class=\"pl-k\">impl</span> <span class=\"pl-en\">IpAddr</span> {\n    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">say</span> (<span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>) {\n        <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{:#?}\"</span>, <span class=\"pl-k\">&amp;</span><span class=\"pl-c1\">self</span>);\n    }\n}\n\n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-k\">let</span> home <span class=\"pl-k\">=</span> IpAddr<span class=\"pl-k\">::</span><span class=\"pl-en\">V4</span>(<span class=\"pl-c1\">127</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>);\n    <span class=\"pl-k\">let</span> loopback <span class=\"pl-k\">=</span> IpAddr<span class=\"pl-k\">::</span><span class=\"pl-en\">V6</span>(<span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"::1\"</span>));\n    home.<span class=\"pl-en\">say</span>();\n    loopback.<span class=\"pl-en\">say</span>();\n}</pre></div>\n<h2 dir=\"auto\">Option与Null</h2>\n<blockquote>\n<p dir=\"auto\">Programming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. <em>Null</em> is a value that means there is no value there. In languages with null, variables can always be in one of two states: <strong>null or not-null.</strong></p>\n<p dir=\"auto\">The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.</p>\n<p dir=\"auto\">However, the concept that null is trying to express is still a useful one: <strong>a null is a value that is currently invalid or absent for some reason.</strong></p>\n<p dir=\"auto\">As such, <strong>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent</strong></p>\n</blockquote>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let some_number = Some(5);\nlet some_string = Some(&quot;a string&quot;);\n\nlet absent_number: Option&lt;i32&gt; = None;\"><pre><span class=\"pl-k\">let</span> some_number <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">5</span>);\n<span class=\"pl-k\">let</span> some_string <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Some</span>(<span class=\"pl-s\">\"a string\"</span>);\n\n<span class=\"pl-k\">let</span> absent_number: <span class=\"pl-k\">Option</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">i32</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>;</pre></div>\n<p dir=\"auto\">因为很常用，所以Some和None都是在prelude里的</p>\n<p dir=\"auto\">不用显式的去写<code class=\"notranslate\">Option::Some</code></p>\n<p dir=\"auto\">所以以上的例子就说有一个已存在的数字，一个已存在的string，还有一个暂时不存在的number，值是None</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let num_0 = 5;\n    let num_1 = Option::Some(5);\n    let num_2 = Option::Some(10);\n    let str_1 = Option::Some(&quot;a string&quot;);\n    let absent_number: Option&lt;i32&gt; = Option::None;\n    \n\t  println!(&quot;{}&quot;, num_1 + num_0); \n    println!(&quot;{}&quot;, num_1.unwrap() + num_0); \n    println!(&quot;{}&quot;, num_1.unwrap() + num_2.unwrap());\n    println!(&quot;{}&quot;, num_1.unwrap() + absent_number.unwrap());\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span> () {\n    <span class=\"pl-k\">let</span> num_0 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;\n    <span class=\"pl-k\">let</span> num_1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">5</span>);\n    <span class=\"pl-k\">let</span> num_2 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">10</span>);\n    <span class=\"pl-k\">let</span> str_1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-s\">\"a string\"</span>);\n    <span class=\"pl-k\">let</span> absent_number: <span class=\"pl-k\">Option</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">i32</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">None</span>;\n    \n\t  <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, num_1 <span class=\"pl-k\">+</span> num_0); \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, num_1.<span class=\"pl-en\">unwrap</span>() <span class=\"pl-k\">+</span> num_0); \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, num_1.<span class=\"pl-en\">unwrap</span>() <span class=\"pl-k\">+</span> num_2.<span class=\"pl-en\">unwrap</span>());\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, num_1.<span class=\"pl-en\">unwrap</span>() <span class=\"pl-k\">+</span> absent_number.<span class=\"pl-en\">unwrap</span>());\n}</pre></div>\n<p dir=\"auto\">这里做一个小实验，在官方文档上其实没有直接教你如何计算和一些异常case</p>\n<p dir=\"auto\">首先，我们肯定不能使用<code class=\"notranslate\">Option&lt;T&gt;</code>类型 去加一个<code class=\"notranslate\">T</code>，这肯定直接报错，例第8行</p>\n<p dir=\"auto\">要使用unwrap去拿出<code class=\"notranslate\">T</code>, 例第9行</p>\n<p dir=\"auto\">在12行，使用一个some去加一个none，但是compiler没有报错，只是在runtime的时候报错了，报错信息为：</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:41:51\"><pre>thread <span class=\"pl-s\"><span class=\"pl-pds\">'</span>main<span class=\"pl-pds\">'</span></span> panicked at <span class=\"pl-s\"><span class=\"pl-pds\">'</span>called `Option::unwrap()` on a `None` value<span class=\"pl-pds\">'</span></span>, src/main.rs:41:51</pre></div>\n<blockquote>\n<p dir=\"auto\">The <code class=\"notranslate\">match</code> expression is a control flow construct that does just this when used with enums: <strong>it will run different code depending on which variant of the enum it has</strong>, and that code can use the data inside the matching value.</p>\n</blockquote>\n<p dir=\"auto\">实际使用Option，参考下文match</p>\n<h2 dir=\"auto\">match</h2>\n<blockquote>\n<p dir=\"auto\">Rust has an extremely powerful control flow operator called <code class=\"notranslate\">match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</p>\n</blockquote>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    #[derive(Debug)] // so we can inspect the state in a minute\n    enum UsState {\n        Alabama,\n        Alaska,\n        // --snip--\n    }\n\n    enum Coin {\n        Penny,\n        Nickel,\n        Dime,\n        Quarter(UsState),\n    }\n    \n    fn value_in_cents(coin: Coin) -&gt; u8 {\n        match coin {\n            Coin::Penny =&gt; 1,\n            Coin::Nickel =&gt; 5,\n            Coin::Dime =&gt; 10,\n            Coin::Quarter(state) =&gt; {\n                match state {\n                    Alabama =&gt; 200,\n                    Alaska =&gt; 30\n                }\n            },\n        }\n    }\n    let coin_1 = Coin::Dime;\n    let coin_2 = Coin::Quarter(UsState::Alabama);\n\n    println!(&quot;{}&quot;, value_in_cents(coin_1)); // 10\n    println!(&quot;{}&quot;, value_in_cents(coin_2)); // 200\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span> () {\n    #[derive(Debug)] <span class=\"pl-c\">// so we can inspect the state in a minute</span>\n    <span class=\"pl-k\">enum</span> <span class=\"pl-en\">UsState</span> {\n        Alabama,\n        Alaska,\n        <span class=\"pl-c\">// --snip--</span>\n    }\n\n    <span class=\"pl-k\">enum</span> <span class=\"pl-en\">Coin</span> {\n        Penny,\n        Nickel,\n        Dime,\n        <span class=\"pl-en\">Quarter</span>(UsState),\n    }\n    \n    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">value_in_cents</span>(coin: Coin) -&gt; <span class=\"pl-k\">u8</span> {\n        <span class=\"pl-k\">match</span> coin {\n            Coin<span class=\"pl-k\">::</span>Penny <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">1</span>,\n            Coin<span class=\"pl-k\">::</span>Nickel <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">5</span>,\n            Coin<span class=\"pl-k\">::</span>Dime <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">10</span>,\n            Coin<span class=\"pl-k\">::</span><span class=\"pl-en\">Quarter</span>(state) <span class=\"pl-k\">=&gt;</span> {\n                <span class=\"pl-k\">match</span> state {\n                    Alabama <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">200</span>,\n                    Alaska <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">30</span>\n                }\n            },\n        }\n    }\n    <span class=\"pl-k\">let</span> coin_1 <span class=\"pl-k\">=</span> Coin<span class=\"pl-k\">::</span>Dime;\n    <span class=\"pl-k\">let</span> coin_2 <span class=\"pl-k\">=</span> Coin<span class=\"pl-k\">::</span><span class=\"pl-en\">Quarter</span>(UsState<span class=\"pl-k\">::</span>Alabama);\n\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, <span class=\"pl-en\">value_in_cents</span>(coin_1)); <span class=\"pl-c\">// 10</span>\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, <span class=\"pl-en\">value_in_cents</span>(coin_2)); <span class=\"pl-c\">// 200</span>\n}</pre></div>\n<p dir=\"auto\">可以理解为很简介的switch case，层层过滤。可以使用 =&gt; 后面紧跟表达式。或者使用{}来拓展多行逻辑。</p>\n<p dir=\"auto\">接着说获取Option里的值并运用的问题</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let num_0 = 5;\n    let num_1 = Option::Some(5);\n    let num_2 = Option::Some(10);\n    let str_1 = Option::Some(&quot;a string&quot;);\n    let absent_number: Option&lt;i32&gt; = Option::None;\n    \n    fn plus_one (num: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match num {\n            Some (v) =&gt; Some(v + 1),\n            None =&gt; None,\n        }\n    }\n    println!(&quot;{:#?}&quot;, plus_one(num_1));\n    println!(&quot;{:#?}&quot;, plus_one(absent_number));\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span> () {\n    <span class=\"pl-k\">let</span> num_0 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;\n    <span class=\"pl-k\">let</span> num_1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">5</span>);\n    <span class=\"pl-k\">let</span> num_2 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">10</span>);\n    <span class=\"pl-k\">let</span> str_1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">Some</span>(<span class=\"pl-s\">\"a string\"</span>);\n    <span class=\"pl-k\">let</span> absent_number: <span class=\"pl-k\">Option</span><span class=\"pl-k\">&lt;</span><span class=\"pl-k\">i32</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">Option</span><span class=\"pl-k\">::</span><span class=\"pl-c1\">None</span>;\n    \n    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">plus_one</span> (num: <span class=\"pl-k\">Option</span>&lt;<span class=\"pl-k\">i32</span>&gt;) -&gt; <span class=\"pl-k\">Option</span>&lt;<span class=\"pl-k\">i32</span>&gt; {\n        <span class=\"pl-k\">match</span> num {\n            <span class=\"pl-c1\">Some</span> (v) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">Some</span>(v <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>),\n            <span class=\"pl-c1\">None</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">None</span>,\n        }\n    }\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{:#?}\"</span>, <span class=\"pl-en\">plus_one</span>(num_1));\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{:#?}\"</span>, <span class=\"pl-en\">plus_one</span>(absent_number));\n}</pre></div>\n<p dir=\"auto\">ln#8使用了定义了一函数，返回Option，在内部使用match进行逻辑流转，如果是个数字，就直接+1，否则返回None</p>\n<p dir=\"auto\">这个函数即可以handle实际存在的Some，也可以涵盖absent的None值</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn plus_one (num: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n  match num { // error: pattern `None` not covered\n    Some (v) =&gt; Some(v + 1),\n  }\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">plus_one</span> (num: <span class=\"pl-k\">Option</span>&lt;<span class=\"pl-k\">i32</span>&gt;) -&gt; <span class=\"pl-k\">Option</span>&lt;<span class=\"pl-k\">i32</span>&gt; {\n  <span class=\"pl-k\">match</span> num { <span class=\"pl-c\">// error: pattern `None` not covered</span>\n    <span class=\"pl-c1\">Some</span> (v) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">Some</span>(v <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>),\n  }\n}</pre></div>\n<p dir=\"auto\">如果不写None这个case，compiler会直接报错。</p>\n<p dir=\"auto\">同时，Rust提供了<code class=\"notranslate\">_</code>的placeholder, 用来匹配所有值</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  let some_u8_value = 0u8;\n  match some_u8_value {\n    1 =&gt; println!(&quot;one&quot;),\n    3 =&gt; println!(&quot;three&quot;),\n    5 =&gt; println!(&quot;five&quot;),\n    7 =&gt; println!(&quot;seven&quot;),\n    _ =&gt; (),\n  }\"><pre>  <span class=\"pl-k\">let</span> some_u8_value <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0u8</span>;\n  <span class=\"pl-k\">match</span> some_u8_value {\n    <span class=\"pl-c1\">1</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"one\"</span>),\n    <span class=\"pl-c1\">3</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"three\"</span>),\n    <span class=\"pl-c1\">5</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"five\"</span>),\n    <span class=\"pl-c1\">7</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"seven\"</span>),\n    _ <span class=\"pl-k\">=&gt;</span> (),\n  }</pre></div>\n<p dir=\"auto\">图中的第7行代表我handle了1357这4个case，其他的都返回空</p>\n<blockquote>\n<p dir=\"auto\">However, the <code class=\"notranslate\">match</code> expression can be a bit wordy in a situation in which we care about only <em>one</em> of the cases. For this situation, Rust provides <code class=\"notranslate\">if let</code>.</p>\n</blockquote>\n<h2 dir=\"auto\">if let</h2>\n<p dir=\"auto\">因为有了<code class=\"notranslate\">_ =&gt; ()</code>这种placeholder，在只想match一种condition的时候，match语法会很累赘。</p>\n<p dir=\"auto\">所以Rust提供了<code class=\"notranslate\">if let</code></p>\n<p dir=\"auto\">以下2种写法一致</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let some_u8_value = Some(0u8);\nmatch some_u8_value {\n  Some(3) =&gt; println!(&quot;three&quot;),\n  _ =&gt; (),\n}\"><pre><span class=\"pl-k\">let</span> some_u8_value <span class=\"pl-k\">=</span> <span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">0u8</span>);\n<span class=\"pl-k\">match</span> some_u8_value {\n  <span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">3</span>) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"three\"</span>),\n  _ <span class=\"pl-k\">=&gt;</span> (),\n}</pre></div>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\" if let Some(3) = some_u8_value {\n   println!(&quot;three&quot;);\n }\"><pre> <span class=\"pl-k\">if</span> <span class=\"pl-k\">let</span> <span class=\"pl-c1\">Some</span>(<span class=\"pl-c1\">3</span>) <span class=\"pl-k\">=</span> some_u8_value {\n   <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"three\"</span>);\n }</pre></div>\n<p dir=\"auto\">为了表示else分支，以下2种也一致。</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let mut count = 0;\nmatch coin {\n  Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),\n  _ =&gt; count += 1,\n}\"><pre><span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> count <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>;\n<span class=\"pl-k\">match</span> coin {\n  Coin<span class=\"pl-k\">::</span><span class=\"pl-en\">Quarter</span>(state) <span class=\"pl-k\">=&gt;</span> <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"State quarter from {:?}!\"</span>, state),\n  _ <span class=\"pl-k\">=&gt;</span> count <span class=\"pl-k\">+=</span> <span class=\"pl-c1\">1</span>,\n}</pre></div>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let mut count = 0;\nif let Coin::Quarter(state) = coin {\n\tprintln!(&quot;State quarter from {:?}!&quot;, state);\n} else {\n\tcount += 1;\n}\"><pre><span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> count <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>;\n<span class=\"pl-k\">if</span> <span class=\"pl-k\">let</span> Coin<span class=\"pl-k\">::</span><span class=\"pl-en\">Quarter</span>(state) <span class=\"pl-k\">=</span> coin {\n\t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"State quarter from {:?}!\"</span>, state);\n} <span class=\"pl-k\">else</span> {\n\tcount <span class=\"pl-k\">+=</span> <span class=\"pl-c1\">1</span>;\n}</pre></div>\n<p dir=\"auto\">可以认为if let是只handle一个case的match的语法糖。</p>\n<p dir=\"auto\">一些个人观点：match的语法累赘再我看来并不是问题，只会让流程更清楚。任何情况下我应该都不会选择使用match</p>"},"__N_SSG":true}