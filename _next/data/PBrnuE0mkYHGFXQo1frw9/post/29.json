{"pageProps":{"html":"<h2 dir=\"auto\">简介</h2>\n<p dir=\"auto\">简述最近碰到的一次re-render问题，解决思路，以及后续的解决方案。</p>\n<h2 dir=\"auto\">问题</h2>\n<p dir=\"auto\">某些组件在不应该re-render的情况下，n次re-render</p>\n<p dir=\"auto\">组件具备以下特性</p>\n<ul dir=\"auto\">\n<li>无props</li>\n<li>数据均订阅至redux store</li>\n</ul>\n<h2 dir=\"auto\">思路描述</h2>\n<p dir=\"auto\">一个组件被更新并re-render，无非</p>\n<ul dir=\"auto\">\n<li>父组件更新导致子组件re-render</li>\n<li>组件的local state更新</li>\n<li>组件的props更新</li>\n<li>组件订阅的global state更新，触发组件re-render</li>\n</ul>\n<p dir=\"auto\">经查证父组件、local state等，只有第四条符合组件被re-render的可能性。组件内均通过useSelector进行global state的绑定（订阅）</p>\n<h2 dir=\"auto\">定位问题</h2>\n<h3 dir=\"auto\">useSelector文档</h3>\n<p dir=\"auto\">通过重新查看redux useSelector的<a href=\"https://react-redux.js.org/api/hooks#equality-comparisons-and-updates\" rel=\"nofollow\">api文档</a>发现。</p>\n<blockquote>\n<p dir=\"auto\">With <code class=\"notranslate\">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>\n</blockquote>\n<p dir=\"auto\">当useSelector返回一个新的对象，会强制re-render。</p>\n<p dir=\"auto\">一个store对象在任意action被dispatch之后，根据flux的规范，需要返回一个完整的store对象。</p>\n<p dir=\"auto\">这句话等同于：store内容本身的指针在每次dispatch后会更新为新的指针，除了dispatch的actions相关的key会变更，其他的state均为merge操作（不考虑primitive类型，仅考虑引用，因为primitive在进行strict equal时较为简单明了）</p>\n<p dir=\"auto\">使用一个简单的reducer举例</p>\n<p dir=\"auto\">例如：</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const setObj = (\n  state,\n  payload,,\n) =&gt; ({\n  ...state,\n  obj: payload,\n})\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">setObj</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span>\n  <span class=\"pl-s1\">state</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s1\">payload</span><span class=\"pl-kos\">,</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">{</span>\n  ...<span class=\"pl-s1\">state</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-c1\">obj</span>: <span class=\"pl-s1\">payload</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">以上setObj action被dispatch后，会设置一个新的obj，及为一个新的指针</p>\n<p dir=\"auto\">使用</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const obj = useSelector((store) =&gt; store.obj)\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-s1\">obj</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">obj</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">当执行<code class=\"notranslate\">dispatch.store.setObj(data)</code>后, obj的指针本身会变化。达到了订阅的目的。</p>\n<p dir=\"auto\">到目前为止都没有问题，结合上文说到的</p>\n<blockquote>\n<p dir=\"auto\">With <code class=\"notranslate\">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>\n</blockquote>\n<p dir=\"auto\">obj变更时，obj确实为一个新的对象，会触发一次re-render</p>\n<h3 dir=\"auto\">多个useSelector的使用</h3>\n<p dir=\"auto\">假设store内有2个obj，且某个组件对这2个obj均进行订阅</p>\n<p dir=\"auto\">例：</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =&gt; {\n  const { objA, ObjB } = useSelector(store =&gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-v\">TestComponent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-kos\">{</span> objA<span class=\"pl-kos\">,</span> ObjB <span class=\"pl-kos\">}</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-c1\">objA</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objA</span><span class=\"pl-kos\">,</span>\n      <span class=\"pl-c1\">objB</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objB</span>\n    <span class=\"pl-kos\">}</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">如果使用上文写法，会造成无意义的re-render问题</p>\n<p dir=\"auto\">再次阅读redux关于useSelector的文档</p>\n<blockquote>\n<p dir=\"auto\">With <code class=\"notranslate\">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>\n</blockquote>\n<p dir=\"auto\">当useSelector被执行后，这个钩子会比对此次selector调用与上次selector调用的结果进行比对，并进行===的strict equal，参考文档：</p>\n<blockquote>\n<p dir=\"auto\">However, when an action is dispatched to the Redux store, <code class=\"notranslate\">useSelector()</code> only forces a re-render if the selector result appears to be different than the last result. As of v7.1.0-alpha.5, the default comparison is a strict <code class=\"notranslate\">===</code> reference comparison. This is different than <code class=\"notranslate\">connect()</code>, which uses shallow equality checks on the results of <code class=\"notranslate\">mapState</code> calls to determine if re-rendering is needed. This has several implications on how you should use <code class=\"notranslate\">useSelector()</code>.</p>\n</blockquote>\n<p dir=\"auto\">回到例子</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =&gt; {\n  const { objA, ObjB } = useSelector(store =&gt; { // 这个selector每次调用都返回新的对象\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-v\">TestComponent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-kos\">{</span> objA<span class=\"pl-kos\">,</span> ObjB <span class=\"pl-kos\">}</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// 这个selector每次调用都返回新的对象</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-c1\">objA</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objA</span><span class=\"pl-kos\">,</span>\n      <span class=\"pl-c1\">objB</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objB</span>\n    <span class=\"pl-kos\">}</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">这也就符合了文档上描述的always force a re-render by default</p>\n<p dir=\"auto\">也就是说当前store作用域内（Provider内），任意一个action被dispatch，例子中的selector被执行后每次都会返回一个新的对象，并会强行触发一个re-render，引发性能问题。</p>\n<h2 dir=\"auto\">关于useSelector的正确使用？？？</h2>\n<h3 dir=\"auto\">方式一</h3>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =&gt; {\n  const { objA, ObjB } = useSelector(store =&gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-v\">TestComponent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-kos\">{</span> objA<span class=\"pl-kos\">,</span> ObjB <span class=\"pl-kos\">}</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-c1\">objA</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objA</span><span class=\"pl-kos\">,</span>\n      <span class=\"pl-c1\">objB</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objB</span>\n    <span class=\"pl-kos\">}</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">结论：<strong>不可用</strong>，每次都返回一个new object，从而导致re-render。</p>\n<h3 dir=\"auto\">方式二：</h3>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =&gt; {\n  const objA = useSelector((store) =&gt; store.objA)\n  const objB = useSelector((store) =&gt; store.objB)\n\n  // ...\n}\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-v\">TestComponent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">objA</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objA</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">objB</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objB</span><span class=\"pl-kos\">)</span>\n\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">结论：<strong>可用</strong>，确实可以解决问题，组件按照预期渲染。useSelector会被调用多次，但是得益于batch patching，不会有性能问题。</p>\n<h3 dir=\"auto\">方式三：</h3>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import { shallowEqual } from 'react-redux'\nconst TestComponent = () =&gt; {\n  const { objA, ObjB } = useSelector(store =&gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  }, shallowEqual)\n  // ...\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s1\">shallowEqual</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">'react-redux'</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-v\">TestComponent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-kos\">{</span> objA<span class=\"pl-kos\">,</span> ObjB <span class=\"pl-kos\">}</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">useSelector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">store</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-c1\">objA</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objA</span><span class=\"pl-kos\">,</span>\n      <span class=\"pl-c1\">objB</span>: <span class=\"pl-s1\">store</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">objB</span>\n    <span class=\"pl-kos\">}</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">shallowEqual</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">结论：<strong>可用</strong>，因为shallowEqual可以保证此次与上次的返回值的比对。告知useSelector这并不是一个新的对象，可以复用原值。从而不会导致re-render。缺点在于：shallowEqual会带来额外的计算损耗。</p>\n<h3 dir=\"auto\">结论四</h3>\n<p dir=\"auto\">使用memorized selector进行选择器缓存。原理跟方式三同理。没有具体实验过，不过赘述。redux文档有比较具体的<a href=\"https://react-redux.js.org/api/hooks#using-memoizing-selectors\" rel=\"nofollow\">说明</a>。</p>\n<h2 dir=\"auto\">总结</h2>\n<p dir=\"auto\">目前看来useSelector的使用总有些变扭，无论是单独写selector的冗余，还是多个selector要使用shallowEqual的额外参数，还是引入reselect做memorized selector，都有额外的理解和开发成本。</p>"},"__N_SSG":true}