{"pageProps":{"html":"<h2 dir=\"auto\">Ownership</h2>\n<p dir=\"auto\">关于内存和GC的说明</p>\n<blockquote>\n<p dir=\"auto\">All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.</p>\n</blockquote>\n<p dir=\"auto\">关于stack和heap</p>\n<blockquote>\n<p dir=\"auto\">All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>\n</blockquote>\n<p dir=\"auto\">关于Rust的GC</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n  let s = String::from(&quot;hello&quot;); // s is valid from this point forward\n  // do stuff with s\n}                                // this scope is now over, and s is no\n                                 // longer valid\"><pre>{\n  <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>); <span class=\"pl-c\">// s is valid from this point forward</span>\n  <span class=\"pl-c\">// do stuff with s</span>\n}                                <span class=\"pl-c\">// this scope is now over, and s is no</span>\n                                 <span class=\"pl-c\">// longer valid</span></pre></div>\n<blockquote>\n<p dir=\"auto\">Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope.<br>\nThere is a natural point at which we can return the memory our <code class=\"notranslate\">String</code> needs to the allocator: when <code class=\"notranslate\">s</code> goes out of scope.</p>\n</blockquote>\n<h2 dir=\"auto\">Move</h2>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let s1 = String::from(&quot;hello&quot;);\nlet s2 = s1;\n\nprintln!(&quot;{}, world!&quot;, s1); // error\"><pre><span class=\"pl-k\">let</span> s1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n<span class=\"pl-k\">let</span> s2 <span class=\"pl-k\">=</span> s1;\n\n<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}, world!\"</span>, s1); <span class=\"pl-c\">// error</span></pre></div>\n<p dir=\"auto\">当S1定义后，S2跟S1指向同一个heap variable。</p>\n<p dir=\"auto\">正常情况，gc时，会去gc s1，然后gc s1对应的heap variable。再去gc s2的时候，s2指向的heap variable已经被gc了。就会导致memory corruption。</p>\n<p dir=\"auto\">为了解决这个问题，Rust采用一种叫做move的策略。当s1定义完，s2指向s1的时候，s1自动变成invalid，即不再有效。</p>\n<p dir=\"auto\">针对stack-only data type，这些type会有一个特殊的anotation叫做Copy的Trait，具有copy trait的类型，可以在move之后继续使用。</p>\n<blockquote>\n<p dir=\"auto\">Here are some of the types that are <code class=\"notranslate\">Copy</code>:</p>\n<ul dir=\"auto\">\n<li>All the integer types, such as <code class=\"notranslate\">u32</code>.</li>\n<li>The Boolean type, <code class=\"notranslate\">bool</code>, with values <code class=\"notranslate\">true</code> and <code class=\"notranslate\">false</code>.</li>\n<li>All the floating point types, such as <code class=\"notranslate\">f64</code>.</li>\n<li>The character type, <code class=\"notranslate\">char</code>.</li>\n<li>Tuples, if they only contain types that are also <code class=\"notranslate\">Copy</code>. For example, <code class=\"notranslate\">(i32, i32)</code> is <code class=\"notranslate\">Copy</code>, but <code class=\"notranslate\">(i32, String)</code> is not.</li>\n</ul>\n</blockquote>\n<h2 dir=\"auto\">Drop</h2>\n<p dir=\"auto\">当一个变量out of scope，Rust会自动call一个叫drop的function来帮助gc。</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main() {\n    let s = String::from(&quot;hello&quot;);\n    takes_ownership(s);\n  \tprintln!(&quot;{}&quot;, s); // error: borrow of moved value: `s`\n    let x = 5;                    \n    makes_copy(x);             \n  \tprintln!(&quot;{}&quot;, x); // fine\n} \nfn takes_ownership(some_string: String) {\n    println!(&quot;{}&quot;, some_string);\n} \nfn makes_copy(some_integer: i32) { \n    println!(&quot;{}&quot;, some_integer);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n    <span class=\"pl-en\">takes_ownership</span>(s);\n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, s); <span class=\"pl-c\">// error: borrow of moved value: `s`</span>\n    <span class=\"pl-k\">let</span> x <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;                    \n    <span class=\"pl-en\">makes_copy</span>(x);             \n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, x); <span class=\"pl-c\">// fine</span>\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">takes_ownership</span>(some_string: <span class=\"pl-k\">String</span>) {\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_string);\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">makes_copy</span>(some_integer: <span class=\"pl-k\">i32</span>) { \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_integer);\n}</pre></div>\n<p dir=\"auto\">第二行定义了s，调用<code class=\"notranslate\">takes_ownership</code>，在第10行打印完后，some_string会out of scope, 因此被drop，</p>\n<p dir=\"auto\">第四行定义了x，integer是拥有Copy Trait Anotation的类型，所以可以继续使用</p>\n<p dir=\"auto\">想要解决第四行这个问题，可以让takes_ownership函数返回一个string，从而达到Transfer Ownership的意义。</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main() {\n    let s = String::from(&quot;hello&quot;);\n    let s = transfer_ownership(s);\n  \tprintln!(&quot;{}&quot;, s); // fine\n    let x = 5;                    \n    makes_copy(x);             \n  \tprintln!(&quot;{}&quot;, x); // fine\n} \nfn transfer_ownership(some_string: String) -&gt; String {\n    println!(&quot;{}&quot;, some_string);\n    return some_string\n} \nfn makes_copy(some_integer: i32) { \n    println!(&quot;{}&quot;, some_integer);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n    <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-en\">transfer_ownership</span>(s);\n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, s); <span class=\"pl-c\">// fine</span>\n    <span class=\"pl-k\">let</span> x <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;                    \n    <span class=\"pl-en\">makes_copy</span>(x);             \n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, x); <span class=\"pl-c\">// fine</span>\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">transfer_ownership</span>(some_string: <span class=\"pl-k\">String</span>) -&gt; <span class=\"pl-k\">String</span> {\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_string);\n    <span class=\"pl-k\">return</span> some_string\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">makes_copy</span>(some_integer: <span class=\"pl-k\">i32</span>) { \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_integer);\n}</pre></div>\n<h2 dir=\"auto\">Reference and Borrowing</h2>\n<p dir=\"auto\">同时上述问题可以使用reference来解决。</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main() {\n    let s = String::from(&quot;hello&quot;);\n    print_string(&amp;s); // 传入引用，而不是move\n  \tprintln!(&quot;{}&quot;, s); // fine\n    let x = 5;                    \n    makes_copy(x);             \n  \tprintln!(&quot;{}&quot;, x); // fine\n} \nfn print_string(some_string: &amp;String) { // 接受一个&amp;String类型的string\n    println!(&quot;{}&quot;, some_string);\n} \n\nfn makes_copy(some_integer: i32) { \n    println!(&quot;{}&quot;, some_integer);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n    <span class=\"pl-en\">print_string</span>(<span class=\"pl-k\">&amp;</span>s); <span class=\"pl-c\">// 传入引用，而不是move</span>\n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, s); <span class=\"pl-c\">// fine</span>\n    <span class=\"pl-k\">let</span> x <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;                    \n    <span class=\"pl-en\">makes_copy</span>(x);             \n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, x); <span class=\"pl-c\">// fine</span>\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">print_string</span>(some_string: <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">String</span>) { <span class=\"pl-c\">// 接受一个&amp;String类型的string</span>\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_string);\n} \n\n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">makes_copy</span>(some_integer: <span class=\"pl-k\">i32</span>) { \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_integer);\n}</pre></div>\n<p dir=\"auto\">reference不会被不拥有ownership的scope drop掉，例如print_string不拥有some_string的ownership，那他就不能drop，只有在main函数执行完才会被drop</p>\n<blockquote>\n<p dir=\"auto\">We call having references as function parameters <em>borrowing</em></p>\n</blockquote>\n<p dir=\"auto\">在传入reference的时候，如果想要修改对应reference的值，可以添加mut</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main() {\n    let mut s = String::from(&quot;hello&quot;);\n  \tprintln!(&quot;original string: {}&quot;, s); \n    print_string(&amp;mut s);\n  \tprintln!(&quot;after change in print string: {}&quot;, s); // fine\n    let x = 5;                    \n    makes_copy(x);             \n  \tprintln!(&quot;{}&quot;, x); // fine\n} \nfn print_string(some_string: &amp;mut String) { // 接受一个&amp;mut String类型的string\n    some_string.push_str(&quot;, world&quot;);\n    println!(&quot;{}&quot;, some_string);\n} \n\nfn makes_copy(some_integer: i32) { \n    println!(&quot;{}&quot;, some_integer);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"original string: {}\"</span>, s); \n    <span class=\"pl-en\">print_string</span>(<span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> s);\n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"after change in print string: {}\"</span>, s); <span class=\"pl-c\">// fine</span>\n    <span class=\"pl-k\">let</span> x <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>;                    \n    <span class=\"pl-en\">makes_copy</span>(x);             \n  \t<span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, x); <span class=\"pl-c\">// fine</span>\n} \n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">print_string</span>(some_string: <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> <span class=\"pl-k\">String</span>) { <span class=\"pl-c\">// 接受一个&amp;mut String类型的string</span>\n    some_string.<span class=\"pl-en\">push_str</span>(<span class=\"pl-s\">\", world\"</span>);\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_string);\n} \n\n<span class=\"pl-k\">fn</span> <span class=\"pl-en\">makes_copy</span>(some_integer: <span class=\"pl-k\">i32</span>) { \n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, some_integer);\n}</pre></div>\n<blockquote>\n<p dir=\"auto\">But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope.</p>\n</blockquote>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let mut s = String::from(&quot;hello&quot;);\n    let r1 = &amp;mut s;\n    let r2 = &amp;mut s; // error: cannot borrow `s` as mutable more than once at a time\n\n    println!(&quot;{}, {}&quot;, r1, r2);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span> () {\n    <span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n    <span class=\"pl-k\">let</span> r1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> s;\n    <span class=\"pl-k\">let</span> r2 <span class=\"pl-k\">=</span> <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> s; <span class=\"pl-c\">// error: cannot borrow `s` as mutable more than once at a time</span>\n\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}, {}\"</span>, r1, r2);\n}</pre></div>\n<blockquote>\n<p dir=\"auto\">The benefit of having this restriction is that Rust can prevent data races at compile time.</p>\n</blockquote>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let mut s = String::from(&quot;hello&quot;);\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    println!(&quot;{} and {}&quot;, r1, r2);\n    // r1 and r2 are no longer used after this point\n    \n    let r3 = &amp;mut s; // no problem\n    println!(&quot;{}&quot;, r3);\n}\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">main</span> () {\n    <span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>);\n\n    <span class=\"pl-k\">let</span> r1 <span class=\"pl-k\">=</span> <span class=\"pl-k\">&amp;</span>s; <span class=\"pl-c\">// no problem</span>\n    <span class=\"pl-k\">let</span> r2 <span class=\"pl-k\">=</span> <span class=\"pl-k\">&amp;</span>s; <span class=\"pl-c\">// no problem</span>\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{} and {}\"</span>, r1, r2);\n    <span class=\"pl-c\">// r1 and r2 are no longer used after this point</span>\n    \n    <span class=\"pl-k\">let</span> r3 <span class=\"pl-k\">=</span> <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">mut</span> s; <span class=\"pl-c\">// no problem</span>\n    <span class=\"pl-c1\">println!</span>(<span class=\"pl-s\">\"{}\"</span>, r3);\n}</pre></div>\n<h2 dir=\"auto\">Dangling Pointer</h2>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn dangle() -&gt; &amp;String { // dangle returns a reference to a String\n\n    let s = String::from(&quot;hello&quot;); // s is a new String\n\n    &amp;s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n  // Danger!\"><pre><span class=\"pl-k\">fn</span> <span class=\"pl-en\">dangle</span>() -&gt; <span class=\"pl-k\">&amp;</span><span class=\"pl-k\">String</span> { <span class=\"pl-c\">// dangle returns a reference to a String</span>\n\n    <span class=\"pl-k\">let</span> s <span class=\"pl-k\">=</span> <span class=\"pl-k\">String</span><span class=\"pl-k\">::</span><span class=\"pl-en\">from</span>(<span class=\"pl-s\">\"hello\"</span>); <span class=\"pl-c\">// s is a new String</span>\n\n    <span class=\"pl-k\">&amp;</span>s <span class=\"pl-c\">// we return a reference to the String, s</span>\n} <span class=\"pl-c\">// Here, s goes out of scope, and is dropped. Its memory goes away.</span>\n  <span class=\"pl-c\">// Danger!</span></pre></div>"},"__N_SSG":true}