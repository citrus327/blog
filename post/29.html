<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Citrus327</title><meta name="description" content="Citrus327 Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/blog/_next/static/css/82f1db8675d0cc14.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/82f1db8675d0cc14.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/f9a979fa4ea39b64.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f9a979fa4ea39b64.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/blog/_next/static/chunks/webpack-4d5208940e01a3dc.js" defer=""></script><script src="/blog/_next/static/chunks/framework-30d8ee4f291f716e.js" defer=""></script><script src="/blog/_next/static/chunks/main-beaf44c65568c517.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-05baf97dde41af4f.js" defer=""></script><script src="/blog/_next/static/chunks/995-6cd8bd0d5e7ab91e.js" defer=""></script><script src="/blog/_next/static/chunks/pages/post/%5Bid%5D-10e4f1d120841a90.js" defer=""></script><script src="/blog/_next/static/Tsx4qfAsMDRA6rvRPAknH/_buildManifest.js" defer=""></script><script src="/blog/_next/static/Tsx4qfAsMDRA6rvRPAknH/_ssgManifest.js" defer=""></script><script src="/blog/_next/static/Tsx4qfAsMDRA6rvRPAknH/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__KdNo5"><header class="Layout_header__TY1Ur"><div class="Avatar_avatar__Wqsgs"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2724%27%20height=%2724%27/%3e"/></span><img alt="avatar" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="Avatar_img__fPm7S" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="avatar" srcSet="https://avatars.githubusercontent.com/u/17166940?v=4 1x, https://avatars.githubusercontent.com/u/17166940?v=4 2x" src="https://avatars.githubusercontent.com/u/17166940?v=4" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="Avatar_img__fPm7S" loading="lazy"/></noscript></span><div class="Avatar_username__94Fmm">citrus327</div></div><div class="Navbar_navbar__dE_dF"><nav class="Navbar_nav__lgcdH"><a href="/blog">Home</a></nav><nav class="Navbar_nav__lgcdH"><a href="/blog/posts">Posts</a></nav></div></header><main class="Layout_main__CO5d2"><div class="markdown-body scroller"><h2 dir="auto">简介</h2>
<p dir="auto">简述最近碰到的一次re-render问题，解决思路，以及后续的解决方案。</p>
<h2 dir="auto">问题</h2>
<p dir="auto">某些组件在不应该re-render的情况下，n次re-render</p>
<p dir="auto">组件具备以下特性</p>
<ul dir="auto">
<li>无props</li>
<li>数据均订阅至redux store</li>
</ul>
<h2 dir="auto">思路描述</h2>
<p dir="auto">一个组件被更新并re-render，无非</p>
<ul dir="auto">
<li>父组件更新导致子组件re-render</li>
<li>组件的local state更新</li>
<li>组件的props更新</li>
<li>组件订阅的global state更新，触发组件re-render</li>
</ul>
<p dir="auto">经查证父组件、local state等，只有第四条符合组件被re-render的可能性。组件内均通过useSelector进行global state的绑定（订阅）</p>
<h2 dir="auto">定位问题</h2>
<h3 dir="auto">useSelector文档</h3>
<p dir="auto">通过重新查看redux useSelector的<a href="https://react-redux.js.org/api/hooks#equality-comparisons-and-updates" rel="nofollow">api文档</a>发现。</p>
<blockquote>
<p dir="auto">With <code class="notranslate">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>
</blockquote>
<p dir="auto">当useSelector返回一个新的对象，会强制re-render。</p>
<p dir="auto">一个store对象在任意action被dispatch之后，根据flux的规范，需要返回一个完整的store对象。</p>
<p dir="auto">这句话等同于：store内容本身的指针在每次dispatch后会更新为新的指针，除了dispatch的actions相关的key会变更，其他的state均为merge操作（不考虑primitive类型，仅考虑引用，因为primitive在进行strict equal时较为简单明了）</p>
<p dir="auto">使用一个简单的reducer举例</p>
<p dir="auto">例如：</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const setObj = (
  state,
  payload,,
) =&gt; ({
  ...state,
  obj: payload,
})"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-s1">setObj</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span>
  <span class="pl-s1">state</span><span class="pl-kos">,</span>
  <span class="pl-s1">payload</span><span class="pl-kos">,</span><span class="pl-kos">,</span>
<span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">(</span><span class="pl-kos">{</span>
  ...<span class="pl-s1">state</span><span class="pl-kos">,</span>
  <span class="pl-c1">obj</span>: <span class="pl-s1">payload</span><span class="pl-kos">,</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span></pre></div>
<p dir="auto">以上setObj action被dispatch后，会设置一个新的obj，及为一个新的指针</p>
<p dir="auto">使用</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const obj = useSelector((store) =&gt; store.obj)"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-s1">obj</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">store</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">obj</span><span class="pl-kos">)</span></pre></div>
<p dir="auto">当执行<code class="notranslate">dispatch.store.setObj(data)</code>后, obj的指针本身会变化。达到了订阅的目的。</p>
<p dir="auto">到目前为止都没有问题，结合上文说到的</p>
<blockquote>
<p dir="auto">With <code class="notranslate">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>
</blockquote>
<p dir="auto">obj变更时，obj确实为一个新的对象，会触发一次re-render</p>
<h3 dir="auto">多个useSelector的使用</h3>
<p dir="auto">假设store内有2个obj，且某个组件对这2个obj均进行订阅</p>
<p dir="auto">例：</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const TestComponent = () =&gt; {
  const { objA, ObjB } = useSelector(store =&gt; {
    return {
      objA: store.objA,
      objB: store.objB
    }
  })
  // ...
}"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">TestComponent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
  <span class="pl-k">const</span> <span class="pl-kos">{</span> objA<span class="pl-kos">,</span> ObjB <span class="pl-kos">}</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-s1">store</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-kos">{</span>
      <span class="pl-c1">objA</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objA</span><span class="pl-kos">,</span>
      <span class="pl-c1">objB</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objB</span>
    <span class="pl-kos">}</span>
  <span class="pl-kos">}</span><span class="pl-kos">)</span>
  <span class="pl-c">// ...</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">如果使用上文写法，会造成无意义的re-render问题</p>
<p dir="auto">再次阅读redux关于useSelector的文档</p>
<blockquote>
<p dir="auto">With <code class="notranslate">useSelector()</code>, returning a new object every time will <em>always</em> force a re-render by default.</p>
</blockquote>
<p dir="auto">当useSelector被执行后，这个钩子会比对此次selector调用与上次selector调用的结果进行比对，并进行===的strict equal，参考文档：</p>
<blockquote>
<p dir="auto">However, when an action is dispatched to the Redux store, <code class="notranslate">useSelector()</code> only forces a re-render if the selector result appears to be different than the last result. As of v7.1.0-alpha.5, the default comparison is a strict <code class="notranslate">===</code> reference comparison. This is different than <code class="notranslate">connect()</code>, which uses shallow equality checks on the results of <code class="notranslate">mapState</code> calls to determine if re-rendering is needed. This has several implications on how you should use <code class="notranslate">useSelector()</code>.</p>
</blockquote>
<p dir="auto">回到例子</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const TestComponent = () =&gt; {
  const { objA, ObjB } = useSelector(store =&gt; { // 这个selector每次调用都返回新的对象
    return {
      objA: store.objA,
      objB: store.objB
    }
  })
  // ...
}"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">TestComponent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
  <span class="pl-k">const</span> <span class="pl-kos">{</span> objA<span class="pl-kos">,</span> ObjB <span class="pl-kos">}</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-s1">store</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span> <span class="pl-c">// 这个selector每次调用都返回新的对象</span>
    <span class="pl-k">return</span> <span class="pl-kos">{</span>
      <span class="pl-c1">objA</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objA</span><span class="pl-kos">,</span>
      <span class="pl-c1">objB</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objB</span>
    <span class="pl-kos">}</span>
  <span class="pl-kos">}</span><span class="pl-kos">)</span>
  <span class="pl-c">// ...</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">这也就符合了文档上描述的always force a re-render by default</p>
<p dir="auto">也就是说当前store作用域内（Provider内），任意一个action被dispatch，例子中的selector被执行后每次都会返回一个新的对象，并会强行触发一个re-render，引发性能问题。</p>
<h2 dir="auto">关于useSelector的正确使用？？？</h2>
<h3 dir="auto">方式一</h3>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const TestComponent = () =&gt; {
  const { objA, ObjB } = useSelector(store =&gt; {
    return {
      objA: store.objA,
      objB: store.objB
    }
  })
  // ...
}"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">TestComponent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
  <span class="pl-k">const</span> <span class="pl-kos">{</span> objA<span class="pl-kos">,</span> ObjB <span class="pl-kos">}</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-s1">store</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-kos">{</span>
      <span class="pl-c1">objA</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objA</span><span class="pl-kos">,</span>
      <span class="pl-c1">objB</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objB</span>
    <span class="pl-kos">}</span>
  <span class="pl-kos">}</span><span class="pl-kos">)</span>
  <span class="pl-c">// ...</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">结论：<strong>不可用</strong>，每次都返回一个new object，从而导致re-render。</p>
<h3 dir="auto">方式二：</h3>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const TestComponent = () =&gt; {
  const objA = useSelector((store) =&gt; store.objA)
  const objB = useSelector((store) =&gt; store.objB)

  // ...
}"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">TestComponent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
  <span class="pl-k">const</span> <span class="pl-s1">objA</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">store</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objA</span><span class="pl-kos">)</span>
  <span class="pl-k">const</span> <span class="pl-s1">objB</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">store</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objB</span><span class="pl-kos">)</span>

  <span class="pl-c">// ...</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">结论：<strong>可用</strong>，确实可以解决问题，组件按照预期渲染。useSelector会被调用多次，但是得益于batch patching，不会有性能问题。</p>
<h3 dir="auto">方式三：</h3>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="import { shallowEqual } from 'react-redux'
const TestComponent = () =&gt; {
  const { objA, ObjB } = useSelector(store =&gt; {
    return {
      objA: store.objA,
      objB: store.objB
    }
  }, shallowEqual)
  // ...
}"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-kos">{</span> <span class="pl-s1">shallowEqual</span> <span class="pl-kos">}</span> <span class="pl-k">from</span> <span class="pl-s">'react-redux'</span>
<span class="pl-k">const</span> <span class="pl-v">TestComponent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
  <span class="pl-k">const</span> <span class="pl-kos">{</span> objA<span class="pl-kos">,</span> ObjB <span class="pl-kos">}</span> <span class="pl-c1">=</span> <span class="pl-en">useSelector</span><span class="pl-kos">(</span><span class="pl-s1">store</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-kos">{</span>
      <span class="pl-c1">objA</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objA</span><span class="pl-kos">,</span>
      <span class="pl-c1">objB</span>: <span class="pl-s1">store</span><span class="pl-kos">.</span><span class="pl-c1">objB</span>
    <span class="pl-kos">}</span>
  <span class="pl-kos">}</span><span class="pl-kos">,</span> <span class="pl-s1">shallowEqual</span><span class="pl-kos">)</span>
  <span class="pl-c">// ...</span>
<span class="pl-kos">}</span></pre></div>
<p dir="auto">结论：<strong>可用</strong>，因为shallowEqual可以保证此次与上次的返回值的比对。告知useSelector这并不是一个新的对象，可以复用原值。从而不会导致re-render。缺点在于：shallowEqual会带来额外的计算损耗。</p>
<h3 dir="auto">结论四</h3>
<p dir="auto">使用memorized selector进行选择器缓存。原理跟方式三同理。没有具体实验过，不过赘述。redux文档有比较具体的<a href="https://react-redux.js.org/api/hooks#using-memoizing-selectors" rel="nofollow">说明</a>。</p>
<h2 dir="auto">总结</h2>
<p dir="auto">目前看来useSelector的使用总有些变扭，无论是单独写selector的冗余，还是多个selector要使用shallowEqual的额外参数，还是引入reselect做memorized selector，都有额外的理解和开发成本。</p></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"html":"\u003ch2 dir=\"auto\"\u003e简介\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e简述最近碰到的一次re-render问题，解决思路，以及后续的解决方案。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e问题\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e某些组件在不应该re-render的情况下，n次re-render\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e组件具备以下特性\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e无props\u003c/li\u003e\n\u003cli\u003e数据均订阅至redux store\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 dir=\"auto\"\u003e思路描述\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e一个组件被更新并re-render，无非\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e父组件更新导致子组件re-render\u003c/li\u003e\n\u003cli\u003e组件的local state更新\u003c/li\u003e\n\u003cli\u003e组件的props更新\u003c/li\u003e\n\u003cli\u003e组件订阅的global state更新，触发组件re-render\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e经查证父组件、local state等，只有第四条符合组件被re-render的可能性。组件内均通过useSelector进行global state的绑定（订阅）\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e定位问题\u003c/h2\u003e\n\u003ch3 dir=\"auto\"\u003euseSelector文档\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003e通过重新查看redux useSelector的\u003ca href=\"https://react-redux.js.org/api/hooks#equality-comparisons-and-updates\" rel=\"nofollow\"\u003eapi文档\u003c/a\u003e发现。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eWith \u003ccode class=\"notranslate\"\u003euseSelector()\u003c/code\u003e, returning a new object every time will \u003cem\u003ealways\u003c/em\u003e force a re-render by default.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003e当useSelector返回一个新的对象，会强制re-render。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e一个store对象在任意action被dispatch之后，根据flux的规范，需要返回一个完整的store对象。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e这句话等同于：store内容本身的指针在每次dispatch后会更新为新的指针，除了dispatch的actions相关的key会变更，其他的state均为merge操作（不考虑primitive类型，仅考虑引用，因为primitive在进行strict equal时较为简单明了）\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e使用一个简单的reducer举例\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e例如：\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const setObj = (\n  state,\n  payload,,\n) =\u0026gt; ({\n  ...state,\n  obj: payload,\n})\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003esetObj\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\n  \u003cspan class=\"pl-s1\"\u003estate\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s1\"\u003epayload\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  ...\u003cspan class=\"pl-s1\"\u003estate\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-c1\"\u003eobj\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003epayload\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e以上setObj action被dispatch后，会设置一个新的obj，及为一个新的指针\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e使用\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const obj = useSelector((store) =\u0026gt; store.obj)\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eobj\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobj\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e当执行\u003ccode class=\"notranslate\"\u003edispatch.store.setObj(data)\u003c/code\u003e后, obj的指针本身会变化。达到了订阅的目的。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e到目前为止都没有问题，结合上文说到的\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eWith \u003ccode class=\"notranslate\"\u003euseSelector()\u003c/code\u003e, returning a new object every time will \u003cem\u003ealways\u003c/em\u003e force a re-render by default.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003eobj变更时，obj确实为一个新的对象，会触发一次re-render\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e多个useSelector的使用\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003e假设store内有2个obj，且某个组件对这2个obj均进行订阅\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e例：\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =\u0026gt; {\n  const { objA, ObjB } = useSelector(store =\u0026gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eTestComponent\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e objA\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e ObjB \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"pl-c\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e如果使用上文写法，会造成无意义的re-render问题\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e再次阅读redux关于useSelector的文档\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eWith \u003ccode class=\"notranslate\"\u003euseSelector()\u003c/code\u003e, returning a new object every time will \u003cem\u003ealways\u003c/em\u003e force a re-render by default.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003e当useSelector被执行后，这个钩子会比对此次selector调用与上次selector调用的结果进行比对，并进行===的strict equal，参考文档：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eHowever, when an action is dispatched to the Redux store, \u003ccode class=\"notranslate\"\u003euseSelector()\u003c/code\u003e only forces a re-render if the selector result appears to be different than the last result. As of v7.1.0-alpha.5, the default comparison is a strict \u003ccode class=\"notranslate\"\u003e===\u003c/code\u003e reference comparison. This is different than \u003ccode class=\"notranslate\"\u003econnect()\u003c/code\u003e, which uses shallow equality checks on the results of \u003ccode class=\"notranslate\"\u003emapState\u003c/code\u003e calls to determine if re-rendering is needed. This has several implications on how you should use \u003ccode class=\"notranslate\"\u003euseSelector()\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003e回到例子\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =\u0026gt; {\n  const { objA, ObjB } = useSelector(store =\u0026gt; { // 这个selector每次调用都返回新的对象\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eTestComponent\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e objA\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e ObjB \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e \u003cspan class=\"pl-c\"\u003e// 这个selector每次调用都返回新的对象\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"pl-c\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这也就符合了文档上描述的always force a re-render by default\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e也就是说当前store作用域内（Provider内），任意一个action被dispatch，例子中的selector被执行后每次都会返回一个新的对象，并会强行触发一个re-render，引发性能问题。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e关于useSelector的正确使用？？？\u003c/h2\u003e\n\u003ch3 dir=\"auto\"\u003e方式一\u003c/h3\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =\u0026gt; {\n  const { objA, ObjB } = useSelector(store =\u0026gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  })\n  // ...\n}\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eTestComponent\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e objA\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e ObjB \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"pl-c\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e结论：\u003cstrong\u003e不可用\u003c/strong\u003e，每次都返回一个new object，从而导致re-render。\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e方式二：\u003c/h3\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const TestComponent = () =\u0026gt; {\n  const objA = useSelector((store) =\u0026gt; store.objA)\n  const objB = useSelector((store) =\u0026gt; store.objB)\n\n  // ...\n}\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eTestComponent\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eobjA\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eobjB\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n\n  \u003cspan class=\"pl-c\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e结论：\u003cstrong\u003e可用\u003c/strong\u003e，确实可以解决问题，组件按照预期渲染。useSelector会被调用多次，但是得益于batch patching，不会有性能问题。\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e方式三：\u003c/h3\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import { shallowEqual } from 'react-redux'\nconst TestComponent = () =\u0026gt; {\n  const { objA, ObjB } = useSelector(store =\u0026gt; {\n    return {\n      objA: store.objA,\n      objB: store.objB\n    }\n  }, shallowEqual)\n  // ...\n}\"\u003e\u003cpre class=\"notranslate\"\u003e\u003cspan class=\"pl-k\"\u003eimport\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eshallowEqual\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-k\"\u003efrom\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e'react-redux'\u003c/span\u003e\n\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eTestComponent\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e objA\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e ObjB \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003euseSelector\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjA\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e: \u003cspan class=\"pl-s1\"\u003estore\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eobjB\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eshallowEqual\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"pl-c\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e结论：\u003cstrong\u003e可用\u003c/strong\u003e，因为shallowEqual可以保证此次与上次的返回值的比对。告知useSelector这并不是一个新的对象，可以复用原值。从而不会导致re-render。缺点在于：shallowEqual会带来额外的计算损耗。\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e结论四\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003e使用memorized selector进行选择器缓存。原理跟方式三同理。没有具体实验过，不过赘述。redux文档有比较具体的\u003ca href=\"https://react-redux.js.org/api/hooks#using-memoizing-selectors\" rel=\"nofollow\"\u003e说明\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e总结\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e目前看来useSelector的使用总有些变扭，无论是单独写selector的冗余，还是多个selector要使用shallowEqual的额外参数，还是引入reselect做memorized selector，都有额外的理解和开发成本。\u003c/p\u003e"},"__N_SSG":true},"page":"/post/[id]","query":{"id":"29"},"buildId":"Tsx4qfAsMDRA6rvRPAknH","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>