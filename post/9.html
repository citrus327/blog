<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Minimal Life</title><meta name="description" content="Minimal Life Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/blog/_next/static/css/ae2bf281c5f69f12.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/ae2bf281c5f69f12.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/dc36ea6314551c03.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/dc36ea6314551c03.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/blog/_next/static/chunks/webpack-4d5208940e01a3dc.js" defer=""></script><script src="/blog/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/blog/_next/static/chunks/main-04fa69cd18d105e9.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f55443f2448c8e66.js" defer=""></script><script src="/blog/_next/static/chunks/247-b84c2316c963d09c.js" defer=""></script><script src="/blog/_next/static/chunks/pages/post/%5Bid%5D-6212bec497a425a5.js" defer=""></script><script src="/blog/_next/static/nUF0YtkFWEE5LEGe--65c/_buildManifest.js" defer=""></script><script src="/blog/_next/static/nUF0YtkFWEE5LEGe--65c/_ssgManifest.js" defer=""></script><script src="/blog/_next/static/nUF0YtkFWEE5LEGe--65c/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__KdNo5"><header class="Layout_header__TY1Ur"><div class="Avatar_avatar__Wqsgs"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2724%27%20height=%2724%27/%3e"/></span><img alt="avatar" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="Avatar_img__fPm7S" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="avatar" srcSet="https://avatars.githubusercontent.com/u/17166940?v=4 1x, https://avatars.githubusercontent.com/u/17166940?v=4 2x" src="https://avatars.githubusercontent.com/u/17166940?v=4" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="Avatar_img__fPm7S" loading="lazy"/></noscript></span><div class="Avatar_username__94Fmm">phshy0607</div></div><div class="Navbar_navbar__dE_dF"><nav class="Navbar_nav__lgcdH"><a href="/blog">Home</a></nav><nav class="Navbar_nav__lgcdH"><a href="/blog/posts">Posts</a></nav></div></header><main class="Layout_main__CO5d2"><div class="markdown-body scroller"><h1 dir="auto">理解Node.js的模块加载</h1>
<blockquote>
<p dir="auto">本文为阅读<a href="https://www.infoq.cn/article/nodejs-module-mechanism/" rel="nofollow">深入浅出 Node.js（三）：深入 Node.js 的模块机制</a>&gt;之后的总结。作为日常的知识储备，方便日后查看和消化。</p>
</blockquote>
<h2 dir="auto">起因</h2>
<p dir="auto">JavaScript本来并没有模块化这一说，作为一种脚本语言却缺少模块化实现就很难在此之上有所拓展。<a href="http://www.commonjs.org" rel="nofollow">CommonJs</a>规范的出现改变了这一点，其最终目标是拓展JavaScript的生态范围。Node.js实现了CommonJs的模块引入规范，NPM实现了包规范。两者契合就有了现在的Node.js模块化。</p>
<h2 dir="auto">模块载入策略</h2>
<p dir="auto">原生模块和文件模块都有模块缓存一说，在载入某模块之后，会缓存起来待之后使用。</p>
<h3 dir="auto">文件模块</h3>
<p dir="auto">这种很常见，因为最基本的命令 <code class="notranslate">node app.js</code> 就是直接将 app.js 作为文件模块引入执行。加载文件模块是由原生模块<code class="notranslate">Module</code>去完成的，该原生模块在启动时已经被加载。</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="// bootstrap main module.
Module.runMain = function () {
    // Load the main module--the command line argument.
    Module._load(process.argv[1], null, true);
};"><pre><span class="pl-c">// bootstrap main module.</span>
<span class="pl-v">Module</span><span class="pl-kos">.</span><span class="pl-en">runMain</span> <span class="pl-c1">=</span> <span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// Load the main module--the command line argument.</span>
    <span class="pl-v">Module</span><span class="pl-kos">.</span><span class="pl-en">_load</span><span class="pl-kos">(</span><span class="pl-s1">process</span><span class="pl-kos">.</span><span class="pl-c1">argv</span><span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">]</span><span class="pl-kos">,</span> <span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span><span class="pl-kos">;</span></pre></div>
<p dir="auto"><code class="notranslate">Module._load</code>静态方法在分析文件名之后，会创建对应Module</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="var module = new Module(id, parent);"><pre><span class="pl-k">var</span> <span class="pl-s1">module</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Module</span><span class="pl-kos">(</span><span class="pl-s1">id</span><span class="pl-kos">,</span> <span class="pl-s1">parent</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<p dir="auto">这里举的例子是用 <code class="notranslate">app.js</code> 为例的，Node.js支持3类文件的解析，分别是 <code class="notranslate">.js</code> <code class="notranslate">.json</code> <code class="notranslate">.node</code></p>
<p dir="auto">Node.js会用一个闭包函数去包装引用文件的内容</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="(function (exports, require, module, __filename, __dirname) {
    // Your file content
});"><pre><span class="pl-kos">(</span><span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-s1">exports</span><span class="pl-kos">,</span> <span class="pl-s1">require</span><span class="pl-kos">,</span> <span class="pl-s1">module</span><span class="pl-kos">,</span> <span class="pl-s1">__filename</span><span class="pl-kos">,</span> <span class="pl-s1">__dirname</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// Your file content</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<p dir="auto">这也是为什么Node.js的模块内，会有类似全局变量的<code class="notranslate">require</code> <code class="notranslate">module</code> <code class="notranslate">export</code> <code class="notranslate">__dirname</code>的存在</p>
<h3 dir="auto">模块查找优先级</h3>
<p dir="auto">在说载入Node.js原生模块之前，先说明一下require的模块查找优先级</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067"><img src="https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067" alt="require的模块查找策略" data-canonical-src="https://static001.infoq.cn/resource/image/85/65/851bca4acc603ce08d1011243191f665.jpg" style="max-width: 100%;"></a></p>
<h3 dir="auto">原生模块</h3>
<p dir="auto">Node.js含有很多原生模块，例如http, fs, path等。<br>
看这个图中会发现，如果目标模块在文件缓存区，原生模块的载入优先级会在文件缓存区之后。</p>
<p dir="auto">也就是说如果你有一个http.js，如果这个文件先被引入（即载入文件缓存区），在之后执行<code class="notranslate">require('http')</code>会直接引入文件而非Node.js原生模块。</p>
<p dir="auto">其实这个场景不会存在，在Node.js环境下，引入文件肯定会是用文件的path，哪怕运行入口和http.js在同级，也就是说</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="const http = require('http')"><pre><span class="pl-k">const</span> <span class="pl-s1">http</span> <span class="pl-c1">=</span> <span class="pl-en">require</span><span class="pl-kos">(</span><span class="pl-s">'http'</span><span class="pl-kos">)</span></pre></div>
<p dir="auto">这个肯定会载入原生模块，文件的引入是用</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="const httpFile = require('./http')"><pre><span class="pl-k">const</span> <span class="pl-s1">httpFile</span> <span class="pl-c1">=</span> <span class="pl-en">require</span><span class="pl-kos">(</span><span class="pl-s">'./http'</span><span class="pl-kos">)</span></pre></div>
<p dir="auto">所以不用担心会有同名的文件模块和原生模块。</p>
<h2 dir="auto">模块查找策略</h2>
<p dir="auto">如果使用require去引入一个模块，其查找优先级是</p>
<ol dir="auto">
<li>从当前文件目录开始查找 node_modules 目录</li>
<li>然后依次进入父目录，查找父目录下的 node_modules 目录</li>
<li>依次迭代，直到根目录下的 node_modules 目录</li>
</ol>
<p dir="auto">如下代码可以在Node.js的环境下使用，这个module.path就是查找的顺序</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="console.log(module.paths);
// 输出
[ 
  '/Users/hao/Work/github/node_module_test/node_modules',
  '/Users/hao/Work/github/node_modules',
  '/Users/hao/Work/node_modules',
  '/Users/hao/node_modules',
  '/Users/node_modules',
  '/node_modules' 
]
"><pre><span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">module</span><span class="pl-kos">.</span><span class="pl-c1">paths</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-c">// 输出</span>
<span class="pl-kos">[</span> 
  <span class="pl-s">'/Users/hao/Work/github/node_module_test/node_modules'</span><span class="pl-kos">,</span>
  <span class="pl-s">'/Users/hao/Work/github/node_modules'</span><span class="pl-kos">,</span>
  <span class="pl-s">'/Users/hao/Work/node_modules'</span><span class="pl-kos">,</span>
  <span class="pl-s">'/Users/hao/node_modules'</span><span class="pl-kos">,</span>
  <span class="pl-s">'/Users/node_modules'</span><span class="pl-kos">,</span>
  <span class="pl-s">'/node_modules'</span> 
<span class="pl-kos">]</span></pre></div>
<p dir="auto">结合之前的图示，完整的策略为：</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067"><img src="https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067" alt="模块查找策略" data-canonical-src="https://static001.infoq.cn/resource/image/14/cb/1416ddabad3dcd4ffca600f88a7613cb.jpg" style="max-width: 100%;"></a></p>
<p dir="auto">简而言之，如果 require 绝对路径的文件，查找时不会去遍历每一个 node_modules 目录，其速度最快。其余流程如下：</p>
<ol dir="auto">
<li>从 module path 数组中取出第一个目录作为查找基准。</li>
<li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。</li>
<li>尝试添加.js、.json、.node 后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li>
<li>尝试将 require 的参数作为一个包来进行查找，读取目录下的 package.json 文件，取得 main 参数指定的文件。</li>
<li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第 3 条查找。</li>
<li>如果继续失败，则取出 module path 数组中的下一个目录作为基准查找，循环第 1 至 5 个步骤。</li>
<li>如果继续失败，循环第 1 至 6 个步骤，直到 module path 中的最后一个值。</li>
<li>如果仍然失败，则抛出异常。</li>
</ol>
<p dir="auto">整个查找过程十分类似原型链的查找和作用域的查找。所幸 Node.js 对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。</p>
<h2 dir="auto">CommonJs 包规范</h2>
<p dir="auto">一个符合 CommonJS 规范的包应该是如下这种结构：</p>
<ol dir="auto">
<li>一个 package.json 文件应该存在于包顶级目录下</li>
<li>二进制文件应该包含在 bin 目录下。</li>
<li>JavaScript 代码应该包含在 lib 目录下。</li>
<li>文档应该在 doc 目录下。</li>
<li>单元测试应该在 test 目录下。</li>
</ol>
<p dir="auto">根据上文说的查找逻辑，其实很重要的一点就是package.json里的main字段。<br>
这个定义了包的入口文件所在。</p>
<h2 dir="auto">为何有些模块可以在Node.js运行也可以在浏览器端运行</h2>
<p dir="auto">浏览器端的Js代码都是通过script标签引入并执行。</p>
<p dir="auto">Node.js是会通过上文中提到的闭包函数去进行包装</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="(function (exports, require, module, __filename, __dirname) {
    // Your file content
});"><pre><span class="pl-kos">(</span><span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-s1">exports</span><span class="pl-kos">,</span> <span class="pl-s1">require</span><span class="pl-kos">,</span> <span class="pl-s1">module</span><span class="pl-kos">,</span> <span class="pl-s1">__filename</span><span class="pl-kos">,</span> <span class="pl-s1">__dirname</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// Your file content</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<p dir="auto">Node.js由于是个闭包，所以不会污染全局变量。浏览器端则不然。<br>
有些包可以在Node.js和浏览器端运行，也是利用闭包和变量检测去完成模块的解析和运行的。<br>
例如著名类库underscore的定义方式</p>
<div class="highlight highlight-source-js notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="(function () {
    // Establish the root object, `window` in the browser, or `global` on the server.
    var root = this;
    var _ = function (obj) {
            return new wrapper(obj);
        };
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' &amp;&amp; module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else if (typeof define === 'function' &amp;&amp; define.amd) {
        // Register as a named module with AMD.
        define('underscore', function () {
            return _;
        });
    } else {
        root['_'] = _;
    }
}).call(this);"><pre><span class="pl-kos">(</span><span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// Establish the root object, `window` in the browser, or `global` on the server.</span>
    <span class="pl-k">var</span> <span class="pl-s1">root</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span><span class="pl-kos">;</span>
    <span class="pl-k">var</span> <span class="pl-en">_</span> <span class="pl-c1">=</span> <span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-s1">obj</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-s1">wrapper</span><span class="pl-kos">(</span><span class="pl-s1">obj</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span><span class="pl-kos">;</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">typeof</span> <span class="pl-s1">exports</span> <span class="pl-c1">!==</span> <span class="pl-s">'undefined'</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">typeof</span> <span class="pl-smi">module</span> <span class="pl-c1">!==</span> <span class="pl-s">'undefined'</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-smi">module</span><span class="pl-kos">.</span><span class="pl-c1">exports</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-s1">exports</span> <span class="pl-c1">=</span> <span class="pl-smi">module</span><span class="pl-kos">.</span><span class="pl-c1">exports</span> <span class="pl-c1">=</span> <span class="pl-en">_</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
        <span class="pl-s1">exports</span><span class="pl-kos">.</span><span class="pl-c1">_</span> <span class="pl-c1">=</span> <span class="pl-en">_</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span> <span class="pl-k">else</span> <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">typeof</span> <span class="pl-s1">define</span> <span class="pl-c1">===</span> <span class="pl-s">'function'</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">define</span><span class="pl-kos">.</span><span class="pl-c1">amd</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-c">// Register as a named module with AMD.</span>
        <span class="pl-en">define</span><span class="pl-kos">(</span><span class="pl-s">'underscore'</span><span class="pl-kos">,</span> <span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-k">return</span> <span class="pl-en">_</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span> <span class="pl-k">else</span> <span class="pl-kos">{</span>
        <span class="pl-s1">root</span><span class="pl-kos">[</span><span class="pl-s">'_'</span><span class="pl-kos">]</span> <span class="pl-c1">=</span> <span class="pl-en">_</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<p dir="auto">以上代码优先检测了exports是否存在，也就是CommonJs规范，如果存在exports对象，直接将目标对象定义在exports上。</p>
<p dir="auto">然后检测了define是否存在，这是amd的模块规范，以适配amd的模块规范。</p>
<p dir="auto">最终如果检测不到CommonJs和AMD的运行环境，则认为是在一个沙盒内运行。</p>
<p dir="auto">可以看到第一行的<code class="notranslate">var root = this</code>，这个this在浏览器端即为window。也就是说如果运行环境既不是CommmonJs也不是AMD，则直接挂在window对象下。</p>
<p dir="auto">现在很多的打包工具都会根据打包的target（UMD, CommonJs等）进行build, 会自动的拼接这些判断，所以其实日常开发js插件/模块，是不需要担心这些环境检测的代码的。</p></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"html":"\u003ch1 dir=\"auto\"\u003e理解Node.js的模块加载\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003e本文为阅读\u003ca href=\"https://www.infoq.cn/article/nodejs-module-mechanism/\" rel=\"nofollow\"\u003e深入浅出 Node.js（三）：深入 Node.js 的模块机制\u003c/a\u003e\u0026gt;之后的总结。作为日常的知识储备，方便日后查看和消化。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 dir=\"auto\"\u003e起因\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003eJavaScript本来并没有模块化这一说，作为一种脚本语言却缺少模块化实现就很难在此之上有所拓展。\u003ca href=\"http://www.commonjs.org\" rel=\"nofollow\"\u003eCommonJs\u003c/a\u003e规范的出现改变了这一点，其最终目标是拓展JavaScript的生态范围。Node.js实现了CommonJs的模块引入规范，NPM实现了包规范。两者契合就有了现在的Node.js模块化。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e模块载入策略\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e原生模块和文件模块都有模块缓存一说，在载入某模块之后，会缓存起来待之后使用。\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e文件模块\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003e这种很常见，因为最基本的命令 \u003ccode class=\"notranslate\"\u003enode app.js\u003c/code\u003e 就是直接将 app.js 作为文件模块引入执行。加载文件模块是由原生模块\u003ccode class=\"notranslate\"\u003eModule\u003c/code\u003e去完成的，该原生模块在启动时已经被加载。\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// bootstrap main module.\nModule.runMain = function () {\n    // Load the main module--the command line argument.\n    Module._load(process.argv[1], null, true);\n};\"\u003e\u003cpre\u003e\u003cspan class=\"pl-c\"\u003e// bootstrap main module.\u003c/span\u003e\n\u003cspan class=\"pl-v\"\u003eModule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-en\"\u003erunMain\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-c\"\u003e// Load the main module--the command line argument.\u003c/span\u003e\n    \u003cspan class=\"pl-v\"\u003eModule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-en\"\u003e_load\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eprocess\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eargv\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e[\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e]\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003enull\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003etrue\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ccode class=\"notranslate\"\u003eModule._load\u003c/code\u003e静态方法在分析文件名之后，会创建对应Module\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"var module = new Module(id, parent);\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003evar\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003emodule\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003enew\u003c/span\u003e \u003cspan class=\"pl-v\"\u003eModule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eid\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eparent\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这里举的例子是用 \u003ccode class=\"notranslate\"\u003eapp.js\u003c/code\u003e 为例的，Node.js支持3类文件的解析，分别是 \u003ccode class=\"notranslate\"\u003e.js\u003c/code\u003e \u003ccode class=\"notranslate\"\u003e.json\u003c/code\u003e \u003ccode class=\"notranslate\"\u003e.node\u003c/code\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNode.js会用一个闭包函数去包装引用文件的内容\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function (exports, require, module, __filename, __dirname) {\n    // Your file content\n});\"\u003e\u003cpre\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eexports\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003erequire\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003emodule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003e__filename\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003e__dirname\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-c\"\u003e// Your file content\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这也是为什么Node.js的模块内，会有类似全局变量的\u003ccode class=\"notranslate\"\u003erequire\u003c/code\u003e \u003ccode class=\"notranslate\"\u003emodule\u003c/code\u003e \u003ccode class=\"notranslate\"\u003eexport\u003c/code\u003e \u003ccode class=\"notranslate\"\u003e__dirname\u003c/code\u003e的存在\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e模块查找优先级\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003e在说载入Node.js原生模块之前，先说明一下require的模块查找优先级\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067\"\u003e\u003cimg src=\"https://camo.githubusercontent.com/a6e579555706a54e58598d567260572a578f3dd02027c9ac6bad4495cc99251d/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f38352f36352f38353162636134616363363033636530386431303131323433313931663636352e6a7067\" alt=\"require的模块查找策略\" data-canonical-src=\"https://static001.infoq.cn/resource/image/85/65/851bca4acc603ce08d1011243191f665.jpg\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3 dir=\"auto\"\u003e原生模块\u003c/h3\u003e\n\u003cp dir=\"auto\"\u003eNode.js含有很多原生模块，例如http, fs, path等。\u003cbr\u003e\n看这个图中会发现，如果目标模块在文件缓存区，原生模块的载入优先级会在文件缓存区之后。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e也就是说如果你有一个http.js，如果这个文件先被引入（即载入文件缓存区），在之后执行\u003ccode class=\"notranslate\"\u003erequire('http')\u003c/code\u003e会直接引入文件而非Node.js原生模块。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e其实这个场景不会存在，在Node.js环境下，引入文件肯定会是用文件的path，哪怕运行入口和http.js在同级，也就是说\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const http = require('http')\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003ehttp\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003erequire\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s\"\u003e'http'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这个肯定会载入原生模块，文件的引入是用\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const httpFile = require('./http')\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003ehttpFile\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003erequire\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s\"\u003e'./http'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e所以不用担心会有同名的文件模块和原生模块。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e模块查找策略\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e如果使用require去引入一个模块，其查找优先级是\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e从当前文件目录开始查找 node_modules 目录\u003c/li\u003e\n\u003cli\u003e然后依次进入父目录，查找父目录下的 node_modules 目录\u003c/li\u003e\n\u003cli\u003e依次迭代，直到根目录下的 node_modules 目录\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e如下代码可以在Node.js的环境下使用，这个module.path就是查找的顺序\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"console.log(module.paths);\n// 输出\n[ \n  '/Users/hao/Work/github/node_module_test/node_modules',\n  '/Users/hao/Work/github/node_modules',\n  '/Users/hao/Work/node_modules',\n  '/Users/hao/node_modules',\n  '/Users/node_modules',\n  '/node_modules' \n]\n\"\u003e\u003cpre\u003e\u003cspan class=\"pl-smi\"\u003econsole\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-en\"\u003elog\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-smi\"\u003emodule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003epaths\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n\u003cspan class=\"pl-c\"\u003e// 输出\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e[\u003c/span\u003e \n  \u003cspan class=\"pl-s\"\u003e'/Users/hao/Work/github/node_module_test/node_modules'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s\"\u003e'/Users/hao/Work/github/node_modules'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s\"\u003e'/Users/hao/Work/node_modules'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s\"\u003e'/Users/hao/node_modules'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s\"\u003e'/Users/node_modules'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"pl-s\"\u003e'/node_modules'\u003c/span\u003e \n\u003cspan class=\"pl-kos\"\u003e]\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e结合之前的图示，完整的策略为：\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067\"\u003e\u003cimg src=\"https://camo.githubusercontent.com/c3905dc5052a66ac918eda25d3d1f437b988bd702923d3cb4d0c90dfd9931449/68747470733a2f2f7374617469633030312e696e666f712e636e2f7265736f757263652f696d6167652f31342f63622f31343136646461626164336463643466666361363030663838613736313363622e6a7067\" alt=\"模块查找策略\" data-canonical-src=\"https://static001.infoq.cn/resource/image/14/cb/1416ddabad3dcd4ffca600f88a7613cb.jpg\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e简而言之，如果 require 绝对路径的文件，查找时不会去遍历每一个 node_modules 目录，其速度最快。其余流程如下：\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e从 module path 数组中取出第一个目录作为查找基准。\u003c/li\u003e\n\u003cli\u003e直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。\u003c/li\u003e\n\u003cli\u003e尝试添加.js、.json、.node 后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。\u003c/li\u003e\n\u003cli\u003e尝试将 require 的参数作为一个包来进行查找，读取目录下的 package.json 文件，取得 main 参数指定的文件。\u003c/li\u003e\n\u003cli\u003e尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第 3 条查找。\u003c/li\u003e\n\u003cli\u003e如果继续失败，则取出 module path 数组中的下一个目录作为基准查找，循环第 1 至 5 个步骤。\u003c/li\u003e\n\u003cli\u003e如果继续失败，循环第 1 至 6 个步骤，直到 module path 中的最后一个值。\u003c/li\u003e\n\u003cli\u003e如果仍然失败，则抛出异常。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e整个查找过程十分类似原型链的查找和作用域的查找。所幸 Node.js 对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003eCommonJs 包规范\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e一个符合 CommonJS 规范的包应该是如下这种结构：\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e一个 package.json 文件应该存在于包顶级目录下\u003c/li\u003e\n\u003cli\u003e二进制文件应该包含在 bin 目录下。\u003c/li\u003e\n\u003cli\u003eJavaScript 代码应该包含在 lib 目录下。\u003c/li\u003e\n\u003cli\u003e文档应该在 doc 目录下。\u003c/li\u003e\n\u003cli\u003e单元测试应该在 test 目录下。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e根据上文说的查找逻辑，其实很重要的一点就是package.json里的main字段。\u003cbr\u003e\n这个定义了包的入口文件所在。\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003e为何有些模块可以在Node.js运行也可以在浏览器端运行\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e浏览器端的Js代码都是通过script标签引入并执行。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNode.js是会通过上文中提到的闭包函数去进行包装\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function (exports, require, module, __filename, __dirname) {\n    // Your file content\n});\"\u003e\u003cpre\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eexports\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003erequire\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003emodule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003e__filename\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003e__dirname\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-c\"\u003e// Your file content\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eNode.js由于是个闭包，所以不会污染全局变量。浏览器端则不然。\u003cbr\u003e\n有些包可以在Node.js和浏览器端运行，也是利用闭包和变量检测去完成模块的解析和运行的。\u003cbr\u003e\n例如著名类库underscore的定义方式\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(function () {\n    // Establish the root object, `window` in the browser, or `global` on the server.\n    var root = this;\n    var _ = function (obj) {\n            return new wrapper(obj);\n        };\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' \u0026amp;\u0026amp; module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else if (typeof define === 'function' \u0026amp;\u0026amp; define.amd) {\n        // Register as a named module with AMD.\n        define('underscore', function () {\n            return _;\n        });\n    } else {\n        root['_'] = _;\n    }\n}).call(this);\"\u003e\u003cpre\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"pl-c\"\u003e// Establish the root object, `window` in the browser, or `global` on the server.\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003evar\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eroot\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003ethis\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003evar\u003c/span\u003e \u003cspan class=\"pl-en\"\u003e_\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eobj\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-k\"\u003enew\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003ewrapper\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s1\"\u003eobj\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003etypeof\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003eexports\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e!==\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e'undefined'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003etypeof\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003emodule\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e!==\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e'undefined'\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003emodule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eexports\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"pl-s1\"\u003eexports\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003emodule\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eexports\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003e_\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"pl-s1\"\u003eexports\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003e_\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003e_\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eelse\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-k\"\u003etypeof\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003edefine\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e===\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e'function'\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"pl-s1\"\u003edefine\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eamd\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"pl-c\"\u003e// Register as a named module with AMD.\u003c/span\u003e\n        \u003cspan class=\"pl-en\"\u003edefine\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-s\"\u003e'underscore'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e,\u003c/span\u003e \u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003e_\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eelse\u003c/span\u003e \u003cspan class=\"pl-kos\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"pl-s1\"\u003eroot\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e[\u003c/span\u003e\u003cspan class=\"pl-s\"\u003e'_'\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e]\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003e_\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\n\u003cspan class=\"pl-kos\"\u003e}\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e.\u003c/span\u003e\u003cspan class=\"pl-en\"\u003ecall\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e(\u003c/span\u003e\u003cspan class=\"pl-smi\"\u003ethis\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e)\u003c/span\u003e\u003cspan class=\"pl-kos\"\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e以上代码优先检测了exports是否存在，也就是CommonJs规范，如果存在exports对象，直接将目标对象定义在exports上。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e然后检测了define是否存在，这是amd的模块规范，以适配amd的模块规范。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e最终如果检测不到CommonJs和AMD的运行环境，则认为是在一个沙盒内运行。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e可以看到第一行的\u003ccode class=\"notranslate\"\u003evar root = this\u003c/code\u003e，这个this在浏览器端即为window。也就是说如果运行环境既不是CommmonJs也不是AMD，则直接挂在window对象下。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e现在很多的打包工具都会根据打包的target（UMD, CommonJs等）进行build, 会自动的拼接这些判断，所以其实日常开发js插件/模块，是不需要担心这些环境检测的代码的。\u003c/p\u003e"},"__N_SSG":true},"page":"/post/[id]","query":{"id":"9"},"buildId":"nUF0YtkFWEE5LEGe--65c","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>