<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Minimal Life</title><meta name="description" content="Minimal Life Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/blog/_next/static/css/6db3845f9f3a867b.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/6db3845f9f3a867b.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/452f28fbf231f2d9.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/452f28fbf231f2d9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/blog/_next/static/chunks/webpack-4d5208940e01a3dc.js" defer=""></script><script src="/blog/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/blog/_next/static/chunks/main-04fa69cd18d105e9.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f55443f2448c8e66.js" defer=""></script><script src="/blog/_next/static/chunks/247-b84c2316c963d09c.js" defer=""></script><script src="/blog/_next/static/chunks/pages/post/%5Bid%5D-5f7ac47925745e56.js" defer=""></script><script src="/blog/_next/static/p7q7UOXOg0qv1CbaWJVCu/_buildManifest.js" defer=""></script><script src="/blog/_next/static/p7q7UOXOg0qv1CbaWJVCu/_ssgManifest.js" defer=""></script><script src="/blog/_next/static/p7q7UOXOg0qv1CbaWJVCu/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__KdNo5"><header class="Layout_header__TY1Ur"><div class="Avatar_avatar__Wqsgs"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2724%27%20height=%2724%27/%3e"/></span><img alt="avatar" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="Avatar_img__fPm7S" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="avatar" srcSet="https://avatars.githubusercontent.com/u/17166940?v=4 1x, https://avatars.githubusercontent.com/u/17166940?v=4 2x" src="https://avatars.githubusercontent.com/u/17166940?v=4" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="Avatar_img__fPm7S" loading="lazy"/></noscript></span><div class="Avatar_username__94Fmm">phshy0607</div></div><div class="Navbar_navbar__dE_dF"><nav class="Navbar_nav__lgcdH"><a href="/blog">Home</a></nav><nav class="Navbar_nav__lgcdH"><a href="/blog/posts">Posts</a></nav></div></header><main class="Layout_main__CO5d2"><div class="markdown-body"><h2 dir="auto">enum</h2>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="enum IpAddrKind {
  V4,
  V6,
}

struct IpAddr {
  kind: IpAddrKind,
  address: String,
}

let home = IpAddr {
  kind: IpAddrKind::V4,
  address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
  kind: IpAddrKind::V6,
  address: String::from(&quot;::1&quot;),
};"><pre><span class="pl-k">enum</span> <span class="pl-en">IpAddrKind</span> {
  V4,
  V6,
}

<span class="pl-k">struct</span> <span class="pl-en">IpAddr</span> {
  kind: IpAddrKind,
  address: <span class="pl-k">String</span>,
}

<span class="pl-k">let</span> home <span class="pl-k">=</span> IpAddr {
  kind: IpAddrKind<span class="pl-k">::</span>V4,
  address: <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-en">from</span>(<span class="pl-s">"127.0.0.1"</span>),
};

<span class="pl-k">let</span> loopback <span class="pl-k">=</span> IpAddr {
  kind: IpAddrKind<span class="pl-k">::</span>V6,
  address: <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-en">from</span>(<span class="pl-s">"::1"</span>),
};</pre></div>
<p dir="auto">声明enum并在struct中使用。</p>
<p dir="auto">想要表达如上的类型，其实可以直接使用enum</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="enum IpAddr {
  V4(String),
  V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));"><pre><span class="pl-k">enum</span> <span class="pl-en">IpAddr</span> {
  <span class="pl-en">V4</span>(<span class="pl-k">String</span>),
  <span class="pl-en">V6</span>(<span class="pl-k">String</span>),
}

<span class="pl-k">let</span> home <span class="pl-k">=</span> IpAddr<span class="pl-k">::</span><span class="pl-en">V4</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-en">from</span>(<span class="pl-s">"127.0.0.1"</span>));

<span class="pl-k">let</span> loopback <span class="pl-k">=</span> IpAddr<span class="pl-k">::</span><span class="pl-en">V6</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-en">from</span>(<span class="pl-s">"::1"</span>));</pre></div>
<p dir="auto">enum跟struct很类似，根据以上的例子可以看出</p>
<ol dir="auto">
<li>使用enum在第一个例子里会比struct更方便</li>
<li>each variant can have different types and amounts of associated data</li>
</ol>
<p dir="auto">enum可以被实现，定义成员方法</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

impl IpAddr {
    fn say (&amp;self) {
        println!(&quot;{:#?}&quot;, &amp;self);
    }
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
    home.say();
    loopback.say();
}"><pre>#[derive(Debug)]
<span class="pl-k">enum</span> <span class="pl-en">IpAddr</span> {
    <span class="pl-en">V4</span>(<span class="pl-k">u8</span>, <span class="pl-k">u8</span>, <span class="pl-k">u8</span>, <span class="pl-k">u8</span>),
    <span class="pl-en">V6</span>(<span class="pl-k">String</span>),
}

<span class="pl-k">impl</span> <span class="pl-en">IpAddr</span> {
    <span class="pl-k">fn</span> <span class="pl-en">say</span> (<span class="pl-k">&amp;</span><span class="pl-c1">self</span>) {
        <span class="pl-c1">println!</span>(<span class="pl-s">"{:#?}"</span>, <span class="pl-k">&amp;</span><span class="pl-c1">self</span>);
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> home <span class="pl-k">=</span> IpAddr<span class="pl-k">::</span><span class="pl-en">V4</span>(<span class="pl-c1">127</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>);
    <span class="pl-k">let</span> loopback <span class="pl-k">=</span> IpAddr<span class="pl-k">::</span><span class="pl-en">V6</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-en">from</span>(<span class="pl-s">"::1"</span>));
    home.<span class="pl-en">say</span>();
    loopback.<span class="pl-en">say</span>();
}</pre></div>
<h2 dir="auto">Option与Null</h2>
<blockquote>
<p dir="auto">Programming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. <em>Null</em> is a value that means there is no value there. In languages with null, variables can always be in one of two states: <strong>null or not-null.</strong></p>
<p dir="auto">The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.</p>
<p dir="auto">However, the concept that null is trying to express is still a useful one: <strong>a null is a value that is currently invalid or absent for some reason.</strong></p>
<p dir="auto">As such, <strong>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent</strong></p>
</blockquote>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;"><pre><span class="pl-k">let</span> some_number <span class="pl-k">=</span> <span class="pl-c1">Some</span>(<span class="pl-c1">5</span>);
<span class="pl-k">let</span> some_string <span class="pl-k">=</span> <span class="pl-c1">Some</span>(<span class="pl-s">"a string"</span>);

<span class="pl-k">let</span> absent_number: <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">i32</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-c1">None</span>;</pre></div>
<p dir="auto">因为很常用，所以Some和None都是在prelude里的</p>
<p dir="auto">不用显式的去写<code class="notranslate">Option::Some</code></p>
<p dir="auto">所以以上的例子就说有一个已存在的数字，一个已存在的string，还有一个暂时不存在的number，值是None</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="fn main () {
    let num_0 = 5;
    let num_1 = Option::Some(5);
    let num_2 = Option::Some(10);
    let str_1 = Option::Some(&quot;a string&quot;);
    let absent_number: Option&lt;i32&gt; = Option::None;
    
	  println!(&quot;{}&quot;, num_1 + num_0); 
    println!(&quot;{}&quot;, num_1.unwrap() + num_0); 
    println!(&quot;{}&quot;, num_1.unwrap() + num_2.unwrap());
    println!(&quot;{}&quot;, num_1.unwrap() + absent_number.unwrap());
}"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span> () {
    <span class="pl-k">let</span> num_0 <span class="pl-k">=</span> <span class="pl-c1">5</span>;
    <span class="pl-k">let</span> num_1 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-c1">5</span>);
    <span class="pl-k">let</span> num_2 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-c1">10</span>);
    <span class="pl-k">let</span> str_1 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-s">"a string"</span>);
    <span class="pl-k">let</span> absent_number: <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">i32</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">None</span>;
    
	  <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, num_1 <span class="pl-k">+</span> num_0); 
    <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, num_1.<span class="pl-en">unwrap</span>() <span class="pl-k">+</span> num_0); 
    <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, num_1.<span class="pl-en">unwrap</span>() <span class="pl-k">+</span> num_2.<span class="pl-en">unwrap</span>());
    <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, num_1.<span class="pl-en">unwrap</span>() <span class="pl-k">+</span> absent_number.<span class="pl-en">unwrap</span>());
}</pre></div>
<p dir="auto">这里做一个小实验，在官方文档上其实没有直接教你如何计算和一些异常case</p>
<p dir="auto">首先，我们肯定不能使用<code class="notranslate">Option&lt;T&gt;</code>类型 去加一个<code class="notranslate">T</code>，这肯定直接报错，例第8行</p>
<p dir="auto">要使用unwrap去拿出<code class="notranslate">T</code>, 例第9行</p>
<p dir="auto">在12行，使用一个some去加一个none，但是compiler没有报错，只是在runtime的时候报错了，报错信息为：</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:41:51"><pre>thread <span class="pl-s"><span class="pl-pds">'</span>main<span class="pl-pds">'</span></span> panicked at <span class="pl-s"><span class="pl-pds">'</span>called `Option::unwrap()` on a `None` value<span class="pl-pds">'</span></span>, src/main.rs:41:51</pre></div>
<blockquote>
<p dir="auto">The <code class="notranslate">match</code> expression is a control flow construct that does just this when used with enums: <strong>it will run different code depending on which variant of the enum it has</strong>, and that code can use the data inside the matching value.</p>
</blockquote>
<p dir="auto">实际使用Option，参考下文match</p>
<h2 dir="auto">match</h2>
<blockquote>
<p dir="auto">Rust has an extremely powerful control flow operator called <code class="notranslate">match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</p>
</blockquote>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="fn main () {
    #[derive(Debug)] // so we can inspect the state in a minute
    enum UsState {
        Alabama,
        Alaska,
        // --snip--
    }

    enum Coin {
        Penny,
        Nickel,
        Dime,
        Quarter(UsState),
    }
    
    fn value_in_cents(coin: Coin) -&gt; u8 {
        match coin {
            Coin::Penny =&gt; 1,
            Coin::Nickel =&gt; 5,
            Coin::Dime =&gt; 10,
            Coin::Quarter(state) =&gt; {
                match state {
                    Alabama =&gt; 200,
                    Alaska =&gt; 30
                }
            },
        }
    }
    let coin_1 = Coin::Dime;
    let coin_2 = Coin::Quarter(UsState::Alabama);

    println!(&quot;{}&quot;, value_in_cents(coin_1)); // 10
    println!(&quot;{}&quot;, value_in_cents(coin_2)); // 200
}"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span> () {
    #[derive(Debug)] <span class="pl-c">// so we can inspect the state in a minute</span>
    <span class="pl-k">enum</span> <span class="pl-en">UsState</span> {
        Alabama,
        Alaska,
        <span class="pl-c">// --snip--</span>
    }

    <span class="pl-k">enum</span> <span class="pl-en">Coin</span> {
        Penny,
        Nickel,
        Dime,
        <span class="pl-en">Quarter</span>(UsState),
    }
    
    <span class="pl-k">fn</span> <span class="pl-en">value_in_cents</span>(coin: Coin) -&gt; <span class="pl-k">u8</span> {
        <span class="pl-k">match</span> coin {
            Coin<span class="pl-k">::</span>Penny <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>,
            Coin<span class="pl-k">::</span>Nickel <span class="pl-k">=&gt;</span> <span class="pl-c1">5</span>,
            Coin<span class="pl-k">::</span>Dime <span class="pl-k">=&gt;</span> <span class="pl-c1">10</span>,
            Coin<span class="pl-k">::</span><span class="pl-en">Quarter</span>(state) <span class="pl-k">=&gt;</span> {
                <span class="pl-k">match</span> state {
                    Alabama <span class="pl-k">=&gt;</span> <span class="pl-c1">200</span>,
                    Alaska <span class="pl-k">=&gt;</span> <span class="pl-c1">30</span>
                }
            },
        }
    }
    <span class="pl-k">let</span> coin_1 <span class="pl-k">=</span> Coin<span class="pl-k">::</span>Dime;
    <span class="pl-k">let</span> coin_2 <span class="pl-k">=</span> Coin<span class="pl-k">::</span><span class="pl-en">Quarter</span>(UsState<span class="pl-k">::</span>Alabama);

    <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, <span class="pl-en">value_in_cents</span>(coin_1)); <span class="pl-c">// 10</span>
    <span class="pl-c1">println!</span>(<span class="pl-s">"{}"</span>, <span class="pl-en">value_in_cents</span>(coin_2)); <span class="pl-c">// 200</span>
}</pre></div>
<p dir="auto">可以理解为很简介的switch case，层层过滤。可以使用 =&gt; 后面紧跟表达式。或者使用{}来拓展多行逻辑。</p>
<p dir="auto">接着说获取Option里的值并运用的问题</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="fn main () {
    let num_0 = 5;
    let num_1 = Option::Some(5);
    let num_2 = Option::Some(10);
    let str_1 = Option::Some(&quot;a string&quot;);
    let absent_number: Option&lt;i32&gt; = Option::None;
    
    fn plus_one (num: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match num {
            Some (v) =&gt; Some(v + 1),
            None =&gt; None,
        }
    }
    println!(&quot;{:#?}&quot;, plus_one(num_1));
    println!(&quot;{:#?}&quot;, plus_one(absent_number));
}"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span> () {
    <span class="pl-k">let</span> num_0 <span class="pl-k">=</span> <span class="pl-c1">5</span>;
    <span class="pl-k">let</span> num_1 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-c1">5</span>);
    <span class="pl-k">let</span> num_2 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-c1">10</span>);
    <span class="pl-k">let</span> str_1 <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">Some</span>(<span class="pl-s">"a string"</span>);
    <span class="pl-k">let</span> absent_number: <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">i32</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Option</span><span class="pl-k">::</span><span class="pl-c1">None</span>;
    
    <span class="pl-k">fn</span> <span class="pl-en">plus_one</span> (num: <span class="pl-k">Option</span>&lt;<span class="pl-k">i32</span>&gt;) -&gt; <span class="pl-k">Option</span>&lt;<span class="pl-k">i32</span>&gt; {
        <span class="pl-k">match</span> num {
            <span class="pl-c1">Some</span> (v) <span class="pl-k">=&gt;</span> <span class="pl-c1">Some</span>(v <span class="pl-k">+</span> <span class="pl-c1">1</span>),
            <span class="pl-c1">None</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>,
        }
    }
    <span class="pl-c1">println!</span>(<span class="pl-s">"{:#?}"</span>, <span class="pl-en">plus_one</span>(num_1));
    <span class="pl-c1">println!</span>(<span class="pl-s">"{:#?}"</span>, <span class="pl-en">plus_one</span>(absent_number));
}</pre></div>
<p dir="auto">ln#8使用了定义了一函数，返回Option，在内部使用match进行逻辑流转，如果是个数字，就直接+1，否则返回None</p>
<p dir="auto">这个函数即可以handle实际存在的Some，也可以涵盖absent的None值</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="fn plus_one (num: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
  match num { // error: pattern `None` not covered
    Some (v) =&gt; Some(v + 1),
  }
}"><pre><span class="pl-k">fn</span> <span class="pl-en">plus_one</span> (num: <span class="pl-k">Option</span>&lt;<span class="pl-k">i32</span>&gt;) -&gt; <span class="pl-k">Option</span>&lt;<span class="pl-k">i32</span>&gt; {
  <span class="pl-k">match</span> num { <span class="pl-c">// error: pattern `None` not covered</span>
    <span class="pl-c1">Some</span> (v) <span class="pl-k">=&gt;</span> <span class="pl-c1">Some</span>(v <span class="pl-k">+</span> <span class="pl-c1">1</span>),
  }
}</pre></div>
<p dir="auto">如果不写None这个case，compiler会直接报错。</p>
<p dir="auto">同时，Rust提供了<code class="notranslate">_</code>的placeholder, 用来匹配所有值</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="  let some_u8_value = 0u8;
  match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
  }"><pre>  <span class="pl-k">let</span> some_u8_value <span class="pl-k">=</span> <span class="pl-c1">0u8</span>;
  <span class="pl-k">match</span> some_u8_value {
    <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"one"</span>),
    <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"three"</span>),
    <span class="pl-c1">5</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"five"</span>),
    <span class="pl-c1">7</span> <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"seven"</span>),
    _ <span class="pl-k">=&gt;</span> (),
  }</pre></div>
<p dir="auto">图中的第7行代表我handle了1357这4个case，其他的都返回空</p>
<blockquote>
<p dir="auto">However, the <code class="notranslate">match</code> expression can be a bit wordy in a situation in which we care about only <em>one</em> of the cases. For this situation, Rust provides <code class="notranslate">if let</code>.</p>
</blockquote>
<h2 dir="auto">if let</h2>
<p dir="auto">因为有了<code class="notranslate">_ =&gt; ()</code>这种placeholder，在只想match一种condition的时候，match语法会很累赘。</p>
<p dir="auto">所以Rust提供了<code class="notranslate">if let</code></p>
<p dir="auto">以下2种写法一致</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="let some_u8_value = Some(0u8);
match some_u8_value {
  Some(3) =&gt; println!(&quot;three&quot;),
  _ =&gt; (),
}"><pre><span class="pl-k">let</span> some_u8_value <span class="pl-k">=</span> <span class="pl-c1">Some</span>(<span class="pl-c1">0u8</span>);
<span class="pl-k">match</span> some_u8_value {
  <span class="pl-c1">Some</span>(<span class="pl-c1">3</span>) <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"three"</span>),
  _ <span class="pl-k">=&gt;</span> (),
}</pre></div>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content=" if let Some(3) = some_u8_value {
   println!(&quot;three&quot;);
 }"><pre> <span class="pl-k">if</span> <span class="pl-k">let</span> <span class="pl-c1">Some</span>(<span class="pl-c1">3</span>) <span class="pl-k">=</span> some_u8_value {
   <span class="pl-c1">println!</span>(<span class="pl-s">"three"</span>);
 }</pre></div>
<p dir="auto">为了表示else分支，以下2种也一致。</p>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="let mut count = 0;
match coin {
  Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
  _ =&gt; count += 1,
}"><pre><span class="pl-k">let</span> <span class="pl-k">mut</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
<span class="pl-k">match</span> coin {
  Coin<span class="pl-k">::</span><span class="pl-en">Quarter</span>(state) <span class="pl-k">=&gt;</span> <span class="pl-c1">println!</span>(<span class="pl-s">"State quarter from {:?}!"</span>, state),
  _ <span class="pl-k">=&gt;</span> count <span class="pl-k">+=</span> <span class="pl-c1">1</span>,
}</pre></div>
<div class="highlight highlight-source-rust notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="let mut count = 0;
if let Coin::Quarter(state) = coin {
	println!(&quot;State quarter from {:?}!&quot;, state);
} else {
	count += 1;
}"><pre><span class="pl-k">let</span> <span class="pl-k">mut</span> count <span class="pl-k">=</span> <span class="pl-c1">0</span>;
<span class="pl-k">if</span> <span class="pl-k">let</span> Coin<span class="pl-k">::</span><span class="pl-en">Quarter</span>(state) <span class="pl-k">=</span> coin {
	<span class="pl-c1">println!</span>(<span class="pl-s">"State quarter from {:?}!"</span>, state);
} <span class="pl-k">else</span> {
	count <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
}</pre></div>
<p dir="auto">可以认为if let是只handle一个case的match的语法糖。</p>
<p dir="auto">一些个人观点：match的语法累赘再我看来并不是问题，只会让流程更清楚。任何情况下我应该都不会选择使用match</p></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"html":"\u003ch2 dir=\"auto\"\u003eenum\u003c/h2\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"enum IpAddrKind {\n  V4,\n  V6,\n}\n\nstruct IpAddr {\n  kind: IpAddrKind,\n  address: String,\n}\n\nlet home = IpAddr {\n  kind: IpAddrKind::V4,\n  address: String::from(\u0026quot;127.0.0.1\u0026quot;),\n};\n\nlet loopback = IpAddr {\n  kind: IpAddrKind::V6,\n  address: String::from(\u0026quot;::1\u0026quot;),\n};\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003eenum\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eIpAddrKind\u003c/span\u003e {\n  V4,\n  V6,\n}\n\n\u003cspan class=\"pl-k\"\u003estruct\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eIpAddr\u003c/span\u003e {\n  kind: IpAddrKind,\n  address: \u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e,\n}\n\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e home \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr {\n  kind: IpAddrKind\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eV4,\n  address: \u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003efrom\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"127.0.0.1\"\u003c/span\u003e),\n};\n\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e loopback \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr {\n  kind: IpAddrKind\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eV6,\n  address: \u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003efrom\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"::1\"\u003c/span\u003e),\n};\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e声明enum并在struct中使用。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e想要表达如上的类型，其实可以直接使用enum\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"enum IpAddr {\n  V4(String),\n  V6(String),\n}\n\nlet home = IpAddr::V4(String::from(\u0026quot;127.0.0.1\u0026quot;));\n\nlet loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;));\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003eenum\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eIpAddr\u003c/span\u003e {\n  \u003cspan class=\"pl-en\"\u003eV4\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e),\n  \u003cspan class=\"pl-en\"\u003eV6\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e),\n}\n\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e home \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eV4\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003efrom\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"127.0.0.1\"\u003c/span\u003e));\n\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e loopback \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eV6\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003efrom\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"::1\"\u003c/span\u003e));\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eenum跟struct很类似，根据以上的例子可以看出\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003e使用enum在第一个例子里会比struct更方便\u003c/li\u003e\n\u003cli\u003eeach variant can have different types and amounts of associated data\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003eenum可以被实现，定义成员方法\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"#[derive(Debug)]\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nimpl IpAddr {\n    fn say (\u0026amp;self) {\n        println!(\u0026quot;{:#?}\u0026quot;, \u0026amp;self);\n    }\n}\n\nfn main() {\n    let home = IpAddr::V4(127, 0, 0, 1);\n    let loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;));\n    home.say();\n    loopback.say();\n}\"\u003e\u003cpre\u003e#[derive(Debug)]\n\u003cspan class=\"pl-k\"\u003eenum\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eIpAddr\u003c/span\u003e {\n    \u003cspan class=\"pl-en\"\u003eV4\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eu8\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003eu8\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003eu8\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003eu8\u003c/span\u003e),\n    \u003cspan class=\"pl-en\"\u003eV6\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e),\n}\n\n\u003cspan class=\"pl-k\"\u003eimpl\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eIpAddr\u003c/span\u003e {\n    \u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003esay\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eself\u003c/span\u003e) {\n        \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{:#?}\"\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eself\u003c/span\u003e);\n    }\n}\n\n\u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e home \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eV4\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e127\u003c/span\u003e, \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e, \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e, \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e loopback \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e IpAddr\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eV6\u003c/span\u003e(\u003cspan class=\"pl-k\"\u003eString\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003efrom\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"::1\"\u003c/span\u003e));\n    home.\u003cspan class=\"pl-en\"\u003esay\u003c/span\u003e();\n    loopback.\u003cspan class=\"pl-en\"\u003esay\u003c/span\u003e();\n}\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 dir=\"auto\"\u003eOption与Null\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eProgramming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. \u003cem\u003eNull\u003c/em\u003e is a value that means there is no value there. In languages with null, variables can always be in one of two states: \u003cstrong\u003enull or not-null.\u003c/strong\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eHowever, the concept that null is trying to express is still a useful one: \u003cstrong\u003ea null is a value that is currently invalid or absent for some reason.\u003c/strong\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAs such, \u003cstrong\u003eRust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let some_number = Some(5);\nlet some_string = Some(\u0026quot;a string\u0026quot;);\n\nlet absent_number: Option\u0026lt;i32\u0026gt; = None;\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e some_number \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e);\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e some_string \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"a string\"\u003c/span\u003e);\n\n\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e absent_number: \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eNone\u003c/span\u003e;\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e因为很常用，所以Some和None都是在prelude里的\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e不用显式的去写\u003ccode class=\"notranslate\"\u003eOption::Some\u003c/code\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e所以以上的例子就说有一个已存在的数字，一个已存在的string，还有一个暂时不存在的number，值是None\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let num_0 = 5;\n    let num_1 = Option::Some(5);\n    let num_2 = Option::Some(10);\n    let str_1 = Option::Some(\u0026quot;a string\u0026quot;);\n    let absent_number: Option\u0026lt;i32\u0026gt; = Option::None;\n    \n\t  println!(\u0026quot;{}\u0026quot;, num_1 + num_0); \n    println!(\u0026quot;{}\u0026quot;, num_1.unwrap() + num_0); \n    println!(\u0026quot;{}\u0026quot;, num_1.unwrap() + num_2.unwrap());\n    println!(\u0026quot;{}\u0026quot;, num_1.unwrap() + absent_number.unwrap());\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003emain\u003c/span\u003e () {\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_0 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e;\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_1 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_2 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e10\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e str_1 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"a string\"\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e absent_number: \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eNone\u003c/span\u003e;\n    \n\t  \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, num_1 \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e num_0); \n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, num_1.\u003cspan class=\"pl-en\"\u003eunwrap\u003c/span\u003e() \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e num_0); \n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, num_1.\u003cspan class=\"pl-en\"\u003eunwrap\u003c/span\u003e() \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e num_2.\u003cspan class=\"pl-en\"\u003eunwrap\u003c/span\u003e());\n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, num_1.\u003cspan class=\"pl-en\"\u003eunwrap\u003c/span\u003e() \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e absent_number.\u003cspan class=\"pl-en\"\u003eunwrap\u003c/span\u003e());\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e这里做一个小实验，在官方文档上其实没有直接教你如何计算和一些异常case\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e首先，我们肯定不能使用\u003ccode class=\"notranslate\"\u003eOption\u0026lt;T\u0026gt;\u003c/code\u003e类型 去加一个\u003ccode class=\"notranslate\"\u003eT\u003c/code\u003e，这肯定直接报错，例第8行\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e要使用unwrap去拿出\u003ccode class=\"notranslate\"\u003eT\u003c/code\u003e, 例第9行\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e在12行，使用一个some去加一个none，但是compiler没有报错，只是在runtime的时候报错了，报错信息为：\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:41:51\"\u003e\u003cpre\u003ethread \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003emain\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e panicked at \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003ecalled `Option::unwrap()` on a `None` value\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e, src/main.rs:41:51\u003c/pre\u003e\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode class=\"notranslate\"\u003ematch\u003c/code\u003e expression is a control flow construct that does just this when used with enums: \u003cstrong\u003eit will run different code depending on which variant of the enum it has\u003c/strong\u003e, and that code can use the data inside the matching value.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003e实际使用Option，参考下文match\u003c/p\u003e\n\u003ch2 dir=\"auto\"\u003ematch\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eRust has an extremely powerful control flow operator called \u003ccode class=\"notranslate\"\u003ematch\u003c/code\u003e that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    #[derive(Debug)] // so we can inspect the state in a minute\n    enum UsState {\n        Alabama,\n        Alaska,\n        // --snip--\n    }\n\n    enum Coin {\n        Penny,\n        Nickel,\n        Dime,\n        Quarter(UsState),\n    }\n    \n    fn value_in_cents(coin: Coin) -\u0026gt; u8 {\n        match coin {\n            Coin::Penny =\u0026gt; 1,\n            Coin::Nickel =\u0026gt; 5,\n            Coin::Dime =\u0026gt; 10,\n            Coin::Quarter(state) =\u0026gt; {\n                match state {\n                    Alabama =\u0026gt; 200,\n                    Alaska =\u0026gt; 30\n                }\n            },\n        }\n    }\n    let coin_1 = Coin::Dime;\n    let coin_2 = Coin::Quarter(UsState::Alabama);\n\n    println!(\u0026quot;{}\u0026quot;, value_in_cents(coin_1)); // 10\n    println!(\u0026quot;{}\u0026quot;, value_in_cents(coin_2)); // 200\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003emain\u003c/span\u003e () {\n    #[derive(Debug)] \u003cspan class=\"pl-c\"\u003e// so we can inspect the state in a minute\u003c/span\u003e\n    \u003cspan class=\"pl-k\"\u003eenum\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eUsState\u003c/span\u003e {\n        Alabama,\n        Alaska,\n        \u003cspan class=\"pl-c\"\u003e// --snip--\u003c/span\u003e\n    }\n\n    \u003cspan class=\"pl-k\"\u003eenum\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eCoin\u003c/span\u003e {\n        Penny,\n        Nickel,\n        Dime,\n        \u003cspan class=\"pl-en\"\u003eQuarter\u003c/span\u003e(UsState),\n    }\n    \n    \u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003evalue_in_cents\u003c/span\u003e(coin: Coin) -\u0026gt; \u003cspan class=\"pl-k\"\u003eu8\u003c/span\u003e {\n        \u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e coin {\n            Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003ePenny \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e,\n            Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eNickel \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e,\n            Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eDime \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e10\u003c/span\u003e,\n            Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eQuarter\u003c/span\u003e(state) \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e state {\n                    Alabama \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e200\u003c/span\u003e,\n                    Alaska \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e30\u003c/span\u003e\n                }\n            },\n        }\n    }\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e coin_1 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eDime;\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e coin_2 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eQuarter\u003c/span\u003e(UsState\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003eAlabama);\n\n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, \u003cspan class=\"pl-en\"\u003evalue_in_cents\u003c/span\u003e(coin_1)); \u003cspan class=\"pl-c\"\u003e// 10\u003c/span\u003e\n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{}\"\u003c/span\u003e, \u003cspan class=\"pl-en\"\u003evalue_in_cents\u003c/span\u003e(coin_2)); \u003cspan class=\"pl-c\"\u003e// 200\u003c/span\u003e\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e可以理解为很简介的switch case，层层过滤。可以使用 =\u0026gt; 后面紧跟表达式。或者使用{}来拓展多行逻辑。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e接着说获取Option里的值并运用的问题\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn main () {\n    let num_0 = 5;\n    let num_1 = Option::Some(5);\n    let num_2 = Option::Some(10);\n    let str_1 = Option::Some(\u0026quot;a string\u0026quot;);\n    let absent_number: Option\u0026lt;i32\u0026gt; = Option::None;\n    \n    fn plus_one (num: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; {\n        match num {\n            Some (v) =\u0026gt; Some(v + 1),\n            None =\u0026gt; None,\n        }\n    }\n    println!(\u0026quot;{:#?}\u0026quot;, plus_one(num_1));\n    println!(\u0026quot;{:#?}\u0026quot;, plus_one(absent_number));\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003emain\u003c/span\u003e () {\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_0 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e;\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_1 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e num_2 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e10\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e str_1 \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"a string\"\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e absent_number: \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-c1\"\u003eNone\u003c/span\u003e;\n    \n    \u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eplus_one\u003c/span\u003e (num: \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u0026lt;\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u0026gt;) -\u0026gt; \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u0026lt;\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u0026gt; {\n        \u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e num {\n            \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e (v) \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(v \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e),\n            \u003cspan class=\"pl-c1\"\u003eNone\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eNone\u003c/span\u003e,\n        }\n    }\n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{:#?}\"\u003c/span\u003e, \u003cspan class=\"pl-en\"\u003eplus_one\u003c/span\u003e(num_1));\n    \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"{:#?}\"\u003c/span\u003e, \u003cspan class=\"pl-en\"\u003eplus_one\u003c/span\u003e(absent_number));\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eln#8使用了定义了一函数，返回Option，在内部使用match进行逻辑流转，如果是个数字，就直接+1，否则返回None\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e这个函数即可以handle实际存在的Some，也可以涵盖absent的None值\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"fn plus_one (num: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; {\n  match num { // error: pattern `None` not covered\n    Some (v) =\u0026gt; Some(v + 1),\n  }\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003efn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eplus_one\u003c/span\u003e (num: \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u0026lt;\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u0026gt;) -\u0026gt; \u003cspan class=\"pl-k\"\u003eOption\u003c/span\u003e\u0026lt;\u003cspan class=\"pl-k\"\u003ei32\u003c/span\u003e\u0026gt; {\n  \u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e num { \u003cspan class=\"pl-c\"\u003e// error: pattern `None` not covered\u003c/span\u003e\n    \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e (v) \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(v \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e),\n  }\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e如果不写None这个case，compiler会直接报错。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e同时，Rust提供了\u003ccode class=\"notranslate\"\u003e_\u003c/code\u003e的placeholder, 用来匹配所有值\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"  let some_u8_value = 0u8;\n  match some_u8_value {\n    1 =\u0026gt; println!(\u0026quot;one\u0026quot;),\n    3 =\u0026gt; println!(\u0026quot;three\u0026quot;),\n    5 =\u0026gt; println!(\u0026quot;five\u0026quot;),\n    7 =\u0026gt; println!(\u0026quot;seven\u0026quot;),\n    _ =\u0026gt; (),\n  }\"\u003e\u003cpre\u003e  \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e some_u8_value \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e0u8\u003c/span\u003e;\n  \u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e some_u8_value {\n    \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"one\"\u003c/span\u003e),\n    \u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"three\"\u003c/span\u003e),\n    \u003cspan class=\"pl-c1\"\u003e5\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"five\"\u003c/span\u003e),\n    \u003cspan class=\"pl-c1\"\u003e7\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"seven\"\u003c/span\u003e),\n    _ \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e (),\n  }\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e图中的第7行代表我handle了1357这4个case，其他的都返回空\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eHowever, the \u003ccode class=\"notranslate\"\u003ematch\u003c/code\u003e expression can be a bit wordy in a situation in which we care about only \u003cem\u003eone\u003c/em\u003e of the cases. For this situation, Rust provides \u003ccode class=\"notranslate\"\u003eif let\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 dir=\"auto\"\u003eif let\u003c/h2\u003e\n\u003cp dir=\"auto\"\u003e因为有了\u003ccode class=\"notranslate\"\u003e_ =\u0026gt; ()\u003c/code\u003e这种placeholder，在只想match一种condition的时候，match语法会很累赘。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e所以Rust提供了\u003ccode class=\"notranslate\"\u003eif let\u003c/code\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e以下2种写法一致\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let some_u8_value = Some(0u8);\nmatch some_u8_value {\n  Some(3) =\u0026gt; println!(\u0026quot;three\u0026quot;),\n  _ =\u0026gt; (),\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e some_u8_value \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e0u8\u003c/span\u003e);\n\u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e some_u8_value {\n  \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"three\"\u003c/span\u003e),\n  _ \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e (),\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\" if let Some(3) = some_u8_value {\n   println!(\u0026quot;three\u0026quot;);\n }\"\u003e\u003cpre\u003e \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eSome\u003c/span\u003e(\u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e some_u8_value {\n   \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"three\"\u003c/span\u003e);\n }\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e为了表示else分支，以下2种也一致。\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let mut count = 0;\nmatch coin {\n  Coin::Quarter(state) =\u0026gt; println!(\u0026quot;State quarter from {:?}!\u0026quot;, state),\n  _ =\u0026gt; count += 1,\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e \u003cspan class=\"pl-k\"\u003emut\u003c/span\u003e count \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"pl-k\"\u003ematch\u003c/span\u003e coin {\n  Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eQuarter\u003c/span\u003e(state) \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"State quarter from {:?}!\"\u003c/span\u003e, state),\n  _ \u003cspan class=\"pl-k\"\u003e=\u0026gt;\u003c/span\u003e count \u003cspan class=\"pl-k\"\u003e+=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e,\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let mut count = 0;\nif let Coin::Quarter(state) = coin {\n\tprintln!(\u0026quot;State quarter from {:?}!\u0026quot;, state);\n} else {\n\tcount += 1;\n}\"\u003e\u003cpre\u003e\u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e \u003cspan class=\"pl-k\"\u003emut\u003c/span\u003e count \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e \u003cspan class=\"pl-k\"\u003elet\u003c/span\u003e Coin\u003cspan class=\"pl-k\"\u003e::\u003c/span\u003e\u003cspan class=\"pl-en\"\u003eQuarter\u003c/span\u003e(state) \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e coin {\n\t\u003cspan class=\"pl-c1\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\"State quarter from {:?}!\"\u003c/span\u003e, state);\n} \u003cspan class=\"pl-k\"\u003eelse\u003c/span\u003e {\n\tcount \u003cspan class=\"pl-k\"\u003e+=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e;\n}\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e可以认为if let是只handle一个case的match的语法糖。\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e一些个人观点：match的语法累赘再我看来并不是问题，只会让流程更清楚。任何情况下我应该都不会选择使用match\u003c/p\u003e"},"__N_SSG":true},"page":"/post/[id]","query":{"id":"22"},"buildId":"p7q7UOXOg0qv1CbaWJVCu","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>